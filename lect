Типы данных
В таблицах могут храниться разные типы данных: целые и дробные числа, текст, даты, массивы из чисел. В наших данных вы встретитесь со следующими типами:

Тип данных	Описание	Пример
INT	Целое число	id пользователя: 132
NUMERIC / DECIMAL	Вещественное число	Стоимость товара: 120.55
VARCHAR	Текст	Действие с заказом: «create_order»
DATE	Дата с точностью до дня	Дата рождения пользователя: 25/03/91
TIMESTAMP	Дата с точностью до секунды	Время регистрации в приложении: 24/08/22 01:52:24
INTEGER[]	Массив	Список id товаров в заказе: [1, 13, 22]
При желании подробнее о типах данных можно почитать здесь.

Структура и наполнение таблиц
user_actions — действия пользователей с заказами. 

Столбец	Тип данных	Описание
user_id	INT	id пользователя
order_id	INT	id заказа
action	VARCHAR(50)	действие пользователя с заказом; 'create_order' — создание заказа, 'cancel_order' — отмена заказа
time	TIMESTAMP	время совершения действия
courier_actions — действия курьеров с заказами.

Столбец	Тип данных	Описание
courier_id	INT	id курьера
order_id	INT	id заказа
action	VARCHAR(50)	действие курьера с заказом; 'accept_order' — принятие заказа, 'deliver_order' — доставка заказа
time	TIMESTAMP	время совершения действия
orders — информация о заказах.

Столбец	Тип данных	Описание
order_id	INT	id заказа 
creation_time	TIMESTAMP	время создания заказа
product_ids	INTEGER[]	список id товаров в заказе
users — информация о пользователях.

Столбец	Тип данных	Описание
user_id 	INT 	id пользователя
birth_date 	DATE	дата рождения
sex 	VARCHAR(50)	пол; 'male' — мужской, 'female' — женский
couriers — информация о курьерах.

Столбец	Тип данных	Описание
courier_id 	INT 	id курьера
birth_date 	DATE	дата рождения
sex 	VARCHAR(50)	пол; 'male' — мужской, 'female' — женский
products — информация о товарах, которые доставляет сервис.

Столбец	Тип данных	Описание
product_id 	INT 	id продукта
name 	VARCHAR(50)	название товара
price 	NUMERIC(5)	цена товара
Примечание:

В скобках у типа данных VARCHAR указано максимально допустимое количество символов в тексте. У типа данных NUMERIC в скобках указано общее число знаков.
Разумеется, запоминать всё это сейчас не нужно. Вы быстро привыкните к типам данных по ходу курса. Пришло время приступать к работе, переходите на следующий урок!

Задача 1.
Первые лекции позади, пора приступать к практике!
Давайте для начала напишем самый простой запрос и посмотрим, как выглядит таблица products.
Чтобы вывести все записи со значениями во всех колонках, необходимо либо перечислить все колонки в операторе SELECT, либо указать после оператора специальный символ «*»:

SELECT column_1, column_2, ...
FROM table
SELECT *
FROM table


На заметку:
Оператор FROM всегда указывается после оператора SELECT. В обратном порядке их записывать нельзя — база данных вернёт ошибку.
Задание:
Выведите все записи из таблицы products.
Поля в результирующей таблице: product_id, name, price
К каждой задаче под специальной кнопкой мы будем приводить результат, который ожидает проверяющая система. Пользоваться кнопкой при решении задачи или нет — решать вам. Однако рекомендуем прибегать к ней только в случае крайней необходимости — старайтесь пробовать писать запросы без неё, как на настоящей работе. 
Для сортировки значений по какой-либо колонке в SQL используется оператор ORDER BY с ключевыми словами ASC (по возрастанию) или DESC (по убыванию).
При этом по умолчанию сортировка происходит по возрастанию, т.е. ASC указывать не обязательно. Для сортировки по убыванию после ORDER BY необходимо явно указать DESC:

SELECT column_1, column_2
FROM table
ORDER BY column_1        -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 ASC    -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC   -- сортировка по убыванию


На заметку:
Оператор ORDER BY всегда указывается после операторов SELECT и FROM.
Задание:
Выведите все записи из таблицы products, отсортировав их по наименованиям товаров в алфавитном порядке, т.е. по возрастанию. Для сортировки используйте оператор ORDER BY.
Поля в результирующей таблице: product_id, name, price
Пояснение:
Сортировку можно делать не только по полям со значениями, выраженными числами, но и по полям, значения в которых представлены в виде текста, как в нашем случае.

Задача 3.
Сортировать результат SQL-запроса можно сразу по нескольким колонкам, указывая их после ORDER BY через запятую вместе с направлением сортировки (ASC или DESC):
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2    -- сначала сортировка по первой колонке (по убыванию), 
                                    -- затем по второй (по возрастанию)


Для ограничения числа извлекаемых из таблицы записей применяется оператор LIMIT.
Записывается он так:

SELECT column
FROM table
LIMIT n 


На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо. Например, 100:

SELECT column
FROM table
LIMIT 100


Если n превысит количество записей в таблице, то в результат попадут все записи.

На заметку:

Важно помнить, что при работе с большими таблицами нужно по возможности ограничивать число извлекаемых записей, чтобы не создавать лишнюю нагрузку на базу данных.

Разумеется, операторы ORDER BY и LIMIT можно совмещать в одном запросе, при этом оператор LIMIT записывается и выполняется после оператора ORDER BY, ограничивая число записей в уже отсортированном результате:

SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2
LIMIT 100


Задание:

Отсортируйте таблицу courier_actions сначала по колонке courier_id по возрастанию id курьера, потом по колонке action (снова по возрастанию), а затем по колонке time, но уже по убыванию — от самого последнего действия к самому первому. Не забудьте включить в результат колонку order_id.
Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.
Поля в результирующей таблице: courier_id, order_id, action, time
Пояснение:
Как вы уже догадались, сортировать таблицы можно в том числе по полям с датами и временем.

Задача 4.
Вот мы и разобрались, как работают операторы ORDER BY и LIMIT.

Сейчас важно запомнить порядок записи всех известных нам ключевых слов:

SELECT
FROM
ORDER BY
LIMIT
Также важно понять, что порядок их выполнения несколько отличается от того, в какой последовательности они указываются в SQL-запросе:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Затем SELECT — отбираются указанные столбцы.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.
Подробнее о порядке выполнения операторов мы будем ещё не раз говорить в последующих уроках. 

А сейчас давайте попробуем с помощью всех этих знаний решить несложную практическую задачу.

Задание:

Используя операторы SELECT, FROM, ORDER BY и LIMIT, определите 5 самых дорогих товаров в таблице products, которые доставляет наш сервис. Выведите их наименования и цену.

Поля в результирующей таблице: name, price

 Ожидаемый результат
Здесь и далее для некоторых задач будут приведены подсказки. Если вы хотите решить задачу без них, просто не раскрывайте скрытый блок.

 Подсказка

Для решения задачи необходимо отсортировать товары по убыванию цены и ограничить число выводимых записей.

Задача 5.
При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена (их ещё называют «алиасами»). Это можно делать с помощью оператора AS:

SELECT name AS new_name
FROM table


Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени и сил, то его можно опустить, указав новое имя колонки без него. Следующая запись тоже сработает:

SELECT name new_name
FROM table


Задание:

Как в прошлом задании определите 5 самых дорогих товаров в таблице products. Но теперь колонки name и price переименуйте соответственно в product_name и product_price.

Поля в результирующей таблице: product_name, product_price


Задача 6.
В SQL-запросах к колонкам таблиц можно применять разные функции — так же, как, например, в Excel.

В общем виде синтаксис функций выглядит примерно так:

SELECT function(a, b, c, ...)
FROM table


Вместо function указывается название функции, а в скобках — её аргументы. В качестве аргументов могут выступать как колонки со значениями, так и отдельные значения. В зависимости от функции количество необходимых для её работы аргументов может отличаться.

Если вы когда-нибудь работали в Excel, то вам наверняка знакомы разные функции вроде SUM, MIN, MAX и т.д., которые производят некоторые вычисления по столбцам. В SQL они называются агрегирующими функциями, и подробно о них мы будет говорить в последующих уроках.

Сейчас же в качестве примера рассмотрим функцию LENGTH. Она выполняет довольно простую задачу — подсчитывает количество символов в поданном ей на вход значении текстового типа (текстовый тип данных ещё часто называют строкой — от англ. «string»). Иными словами, функция LENGTH измеряет длину некоторой строки в символах:

SELECT LENGTH('karpov.courses')

Результат:
14


Функция LENGTH также может применяться ко всему столбцу. В таком случае длина в символах будет посчитана для каждого значения в столбце. Соответствующий запрос будет выглядеть так:

SELECT LENGTH(column) AS column_length
FROM table


Задание:

Используя операторы SELECT, FROM, ORDER BY и LIMIT, а также функцию LENGTH, определите товар с самым длинным названием в таблице products. Выведите его наименование, длину наименования в символах, а также цену этого товара. Колонку с длиной наименования в символах назовите name_length.

Поля в результирующей таблице: name, name_length, price

Пояснение:

Обратите внимание, что в этой задаче вам придётся сортировать результирующую таблицу по расчётной колонке name_length, которой изначально не было в таблице products.

Такая сортировка по новым колонкам возможна, поскольку это согласуется с порядком выполнения операторов в запросе: сначала выполняется выбор колонок и все преобразования над ними в операторе SELECT — и только потом производится сортировка по указанным в ORDER BY столбцам. То есть к моменту сортировки все расчётные поля уже существуют, а значит, их можно указывать в ORDER BY.

Также обратите внимание, что мы дважды указываем колонку name в операторе SELECT: в первый раз просто обращаемся к ней по имени, а во второй — используем её в качестве аргумента функции LENGTH. В этом случае тоже нет никаких противоречий — мы можем выбирать колонку столько раз, сколько необходимо, причём для этого даже необязательно присваивать этим колонкам разные алиасы (база данных сама переименует дубликат колонки).

Задача 7.
В SQL, как и во многих других языках, функции можно применять к результату других функций, т.е. последовательно:

SELECT function_one(function_two(a, b), c)


В приведённой выше конструкции a, b, c — аргументы функций. При этом одним из аргументов функции function_one является результат выполнения функции function_two.

Таким образом, сначала будет выполнена функция function_two, а затем её результат будет подан на вход функции function_one в качестве одного из аргументов.

Рассмотрим такой случай на примере функций UPPER и LEFT. Функция UPPER приводит поданное ей на вход текстовое значение к верхнему регистру, а функция LEFT — возвращает первые n символов в строке:

SELECT UPPER('karpov.courses')

Результат:
KARPOV.COURSES


SELECT LEFT('karpov.courses', 6)

Результат:
karpov


Мы можем применить эти функции последовательно, и в результате получим первые шесть символов верхнего регистра:

SELECT UPPER(LEFT('karpov.courses', 6)) AS new_name

Результат:
KARPOV


Важно: обратите внимание, что в блоке SELECT нельзя выполнить эти две операции раздельно, т.е. мы не можем сначала создать расчётную колонку с первыми шестью символами, а потом сразу же обратиться к этой новой колонке, применив к ней функцию UPPER. Следующий запрос выполнен не будет, база данных вернёт ошибку:

SELECT LEFT('karpov.courses', 6) AS new_name, UPPER(new_name) AS another_new_name

Результат:
Error running query: column "new_name" does not exist


В рамках одного запроса колонки создаются не по очереди, а вместе, поэтому в рамках одного запроса колонки new_name не существует, пока блок SELECT не будет выполнен полностью. Крайне важно учитывать эту особенность языка.

Однако на практике к новым колонкам приходится обращаться довольно часто — именно для этого существуют подзапросы (запросы к другим запросам), которые мы будем рассматривать в соответствующем уроке. А пока нам достаточно понимать, что применять функции к расчётным колонкам в том же запросе нельзя.

В следующей задаче мы будем использовать ещё одну функцию для работы с данными строкового типа — SPLIT_PART. Функция SPLIT_PART разбивает поданную ей на вход строку на несколько частей в соответствии с указанным разделителем и возвращает одну из частей.

Помимо самой строки (или колонки со значениями строкового типа) функция принимает ещё два аргумента — разделитель и порядковый номер части, которую необходимо вернуть. Посмотрите на следующий пример:

SELECT SPLIT_PART('karpov.courses', '.', 2)

Результат:
courses


В примере выше строка 'karpov.courses' была разбита на две части ('karpov' и 'courses') по разделителю, выраженному символом «точка». Функция вернула 'courses', поскольку третьим аргументом мы указали часть с порядковым номером 2.

На заметку:

Подробнее с другими функциями для работы со строками можно ознакомиться здесь.

Задание:

Примените последовательно функции UPPER и SPLIT_PART к колонке name и преобразуйте наименования товаров в таблице products так, чтобы от названий осталось только первое слово, записанное в верхнем регистре. Колонку с новым названием, состоящим из первого слова, назовите first_word.

В результат включите исходные наименования товаров, новые наименования из первого слова, а также цену товаров. Результат отсортируйте по возрастанию исходного наименования товара в колонке name.

Поля в результирующей таблице: name, first_word, price


Задача 8.
Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, не меняя при этом свойства исходной таблицы — например, преобразовать число в текст (тип данных VARCHAR). Для этого существует функция CAST.

На вход функции CAST необходимо подать имя колонки, указав через AS тип данных, к которому нужно привести все значения:

SELECT CAST(column AS VARCHAR)
FROM table


Также изменить тип данных можно с помощью специального синтаксиса с двумя двоеточиями («::»):

SELECT column::VARCHAR
FROM table


Можете самостоятельно запустить в Redash следующий запрос:

SELECT CAST('100' AS INTEGER)

Результат:
100


В примере выше вместо колонки мы использовали всего одно значение и перевели текст '100' в число 100.

Обратите внимание, что для успешной конвертации значения должны быть конвертируемыми в указываемый тип. Например, текст, который не выглядит как число, перевести в числовой тип данных не получится:

SELECT CAST('text' AS INTEGER)

Результат:
Error running query: invalid input syntax for type integer: "text"


Аналогичным образом можно, например, преобразовать текст в дату (если он выглядит как дата):

SELECT '2022-12-31'::DATE

Результат:
31/12/22


На заметку:

В Redash тип данных в колонке указан справа от её названия.

Подробнее с функцией CAST и преобразованием типов данных можно ознакомиться здесь.

Про сами типы данных можно почитать тут.

Задание:

Измените тип колонки price из таблицы products на VARCHAR. Выведите колонки с наименованием товаров, ценой в исходном формате и ценой в формате VARCHAR. Новую колонку с ценой в новом формате назовите price_char.

Результат отсортируйте по возрастанию наименования товара в колонке name. Количество выводимых записей не ограничивайте.

Поле в результирующей таблице: name, price, price_char

Задача 9.
В этом задании ещё немного поработаем с текстовыми данными и рассмотрим функцию CONCAT, с помощью которой можно соединять в одну строку значения из нескольких столбцов. 

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами:

SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022


При этом аргументы не обязательно должны быть выражены текстовыми значениями — главное, они должны быть конвертируемыми в текст. В примере выше число 2022 можно конвертировать в текст '2022', поэтому запрос работает без ошибок.

На заметку:

Ознакомиться с другими примерами использования функции CONCAT можно здесь.

Задание:

Для первых 200 записей из таблицы orders выведите информацию в следующем виде (обратите внимание на пробелы):

Заказ № [id заказа] создан [дата]

Полученную колонку назовите order_info.

Пример вывода:

Заказ № 65 создан 2022-09-01


Пояснение:

При указании текстовых значений используйте одинарные кавычки. Пробелы вносите вместе со словами, а не отдельными текстовыми значениями.

Чтобы извлечь дату из значений в колонке creation_time, достаточно применить к ней функцию DATE или изменить её тип на DATE:

SELECT DATE(time)

SELECT CAST(time AS DATE)

SELECT time::DATE

Задача 10.
Как вы уже заметили, в наших таблицах значения в некоторых колонках представлены в формате даты (DATE) и времени (TIMESTAMP). Давайте немного поработаем и с такими данными.

На практике часто встречаются задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Её синтаксис следующий:

SELECT DATE_PART(part, column)


На месте part необходимо в кавычках указать ту часть, которую нужно извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату или время. Можете самостоятельно запустить в Redash следующие запросы:

SELECT DATE_PART('year', DATE '2022-01-12')

Результат:
2022.00


SELECT DATE_PART('month', DATE '2022-01-12')

Результат:
1.00


SELECT DATE_PART('day', DATE '2022-01-12')

Результат:
12.00


SELECT DATE_PART('hour', TIMESTAMP '2022-01-12 20:31:05')

Результат:
20.00


SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')

Результат:
31.00


Выше в качестве примера мы указали конкретную дату. На её месте могла быть, например, колонка с датами dates. Тогда запрос выглядел бы так:

SELECT DATE_PART('day', dates)


На заметку:

Ознакомиться с другими примерами использования функции DATE_PART можно здесь.

Задание:

Выведите id всех курьеров и их годы рождения из таблицы couriers.

Год рождения необходимо получить из колонки birth_date. Новую колонку с годом назовите birth_year. Результат отсортируйте сначала по убыванию года рождения курьера (т.е. от самых младших к самым старшим), затем по возрастанию id курьера.

Поля в результирующей таблице: courier_id, birth_year

* Задача 11.
А теперь задача поинтереснее.

Вы могли заметить, что в прошлом задании для отдельных строк функция DATE_PART не вернула год рождения курьера — вместо них образовались пустые значения. Если не заметили, посмотрите внимательно на результат запроса из прошлого задания.

На самом деле это произошло потому, что в наших данных в колонке birth_date есть пропуски — так называемые NULL значения. Иными словами, для отдельных курьеров просто не указаны их дни рождения. Есть масса вариантов, почему так могло произойти, но у нас сейчас нет времени всё это выяснять — нам просто нужно научиться как-то обрабатывать такие случаи.

Давайте сделаем так, чтобы вместо пустых значений функция DATE_PART возвращала какое-нибудь другое значение. В этом нам поможет функция COALESCE, которая возвращает первое не NULL значение из списка поданных ей на вход аргументов.

Работу COALESCE можно описать следующим образом: она буквально читает список значений слева направо и, как только видит значение, которое не является NULL, сразу же возвращает его и прекращает чтение списка. Посмотрите внимательно на следующие примеры:

SELECT COALESCE(NULL, 'I am not NULL' , 'karpov.courses')

Результат:
I am not NULL


SELECT COALESCE(NULL, 25, 100, 150)

Результат:
25


SELECT COALESCE('NULL', 'I am not NULL', 'karpov.courses')

Результат:
NULL


Одним из аргументов функции COALESCE может выступать результат выполнения другой функции:

SELECT COALESCE(NULL, LOWER('I am not NULL'), 'karpov.courses')

Результат:
i am not null


Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:

SELECT COALESCE(column, 'filler value')
FROM table


Функция COALESCE применится к каждому значению в колонке. Если это значение окажется NULL, она заменит его на значение, указанное вторым аргументом. Если значение в колонке, наоборот, окажется не NULL, то функция просто вернёт это значение.

При этом к колонке с пропусками можно также заранее применять разные другие функции:

SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table


На заметку:

С другими примерами использования функции COALESCE можно ознакомиться здесь.

Задание:

Как и в предыдущем задании, снова выведите id всех курьеров и их годы рождения, только теперь к извлеченному году примените функцию COALESCE. Укажите параметры функции так, чтобы вместо NULL значений в результат попадало текстовое значение unknown. Названия полей оставьте прежними.

Отсортируйте итоговую таблицу сначала по убыванию года рождения курьера, затем по возрастанию id курьера.

Поля в результирующей таблице: courier_id, birth_year

Пояснение:

При указании текстового значения используйте одинарные кавычки, как в примерах выше.

Не забудьте учесть, что unknown — значение типа VARCHAR, а значит, извлечённый из даты год нужно тоже привести к этому типу. Поэтому сначала извлеките год, затем преобразуйте его в текст и далее применяйте к полученному значению функцию COALESCE.

Задача 12.
Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы. Ниже в таблице указаны наиболее популярные:

Оператор| Описание	          |Пример |  Результат
+	      | Сложение	          |2 + 3	|  5
-	      | Вычитание	          |2 - 3	|  -1
*	      | Умножение	          |2 * 3	|  6
/	      | Деление	            |4 / 2	|  2
%	      | Остаток от деления	|5 % 4	|  1
^	      | Возведение в степень|2 ^ 3	|  8
Пример:

Если бы мы захотели перевести 7500 рублей в доллары по курсу 1 доллар = 75 рублей, то операция выглядела бы следующим образом:

SELECT 7500 / 75

Результат:
100


Если бы нам потребовалось вычесть из каждого значения в одной из колонок нашей таблицы какое-то число (допустим, 100), то запрос выглядел бы так:

SELECT column - 100
FROM table


Кроме того, в арифметических операциях могут принимать участие сразу несколько колонок. Например, для каждой строчки таблицы можно вычислить среднее арифметическое двух чисел, которые содержатся в двух разных колонках:

SELECT (column_1 + column_2) / 2 AS average
FROM table


На заметку:

Ознакомиться со всеми арифметическими операторами можно здесь.

Задание:

Давайте представим, что по какой-то необъяснимой причине мы вдруг решили в одночасье повысить цену всех товаров в таблице products на 5%.

Выведите id и наименования всех товаров, их старую и новую цену. Колонку со старой ценой назовите old_price, а колонку с новой — new_price.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price

Задача 13.
Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND:

SELECT ROUND(100.5454, 2)

Результат:
100.55


SELECT ROUND(100.551, 1)

Результат:
100.6


SELECT ROUND(100.5511)

Результат:
101.0



Первым аргументом указывается само значение, которое хотим округлить. Вторым — число знаков после точки, до которого хотим округлить. Второй аргумент указывать не обязательно: если его не указать, произойдёт округление до целого числа (однако тип данных при этом не поменяется).

Также обратите внимание, что Redash накладывает дополнительное форматирование на выводимый результат, поэтому, например, результат второго запроса с настройками по умолчанию будет выглядеть так: 100.60

Настроить формат отображения и задать вручную число знаков после запятой можно с помощью кнопки Edit Visualization, расположенной в интерфейсе Redash сразу под результатом запроса.

На заметку:

Ознакомиться с другими математическими функциями можно здесь.

Задание:

Вновь, как и в прошлом задании, повысьте цену всех товаров на 5%, только теперь к колонке с новой ценой примените функцию ROUND. Выведите id и наименования товаров, их старую цену, а также новую цену с округлением. Новую цену округлите до одного знака после запятой, но тип данных не меняйте.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price

Задача 14.
А что если бы мы захотели повысить цену не на все товары, а, скажем, только на дорогие?

Для этого нам бы потребовалось создать некоторую функцию, которая проверяла бы каждое значение в колонке price и сравнивала бы его с каким-то пороговым значением. Если бы цена оказывалась выше этого порога, то функция повышала бы цену, а если нет — оставляла бы без изменений.

И такую функцию как раз можно задать с помощью условной конструкции CASE. Она имеет следующий синтаксис:

CASE  
WHEN logical_expression_1 THEN expression_1
WHEN logical_expression_2 THEN expression_2
...
ELSE expression_else
END AS case_example


Эта конструкция может показаться громоздкой, но на самом деле в ней нет ничего сложного. Логика работы оператора CASE довольно простая:

На каждом этапе WHEN – THEN вычисляется некоторое логическое выражение logical_expression, стоящее после WHEN. Если оно оказывается истинным (TRUE), то в качестве результата оператор возвращает выражение expression, стоящее после THEN, и заканчивает свою работу.
Если выражение оказывается ложным (FALSE), то оператор продолжает работу и проверяет следующее условие.
Если ни одно из условий не проходит проверку на истинность, то возвращается выражение, указанное после ELSE. При этом ELSE указывать не обязательно — если его не указать, то вернётся пустое значение NULL (в случае, если все проверки после WHEN оказались ложными).
В конце обязательно указывается ключевое слово END, которое говорит об окончании конструкции CASE. Также после END новому расчётному полю с помощью AS можно присвоить некоторое имя, но это делать не обязательно. Обязательными являются только ключевые слова CASE,  WHEN,  THEN и END.
Пример:

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое».

SELECT name,
       CASE 
       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table


Теперь немного о логических выражениях: в SQL они могут включать операторы сравнения и логические операции.

К операторам сравнения относятся:

= («равно»)
<> или != («не равно»)
< («меньше»)
> («больше»)
<= («меньше или равно»)
>= («больше или равно»)
Результатом работы операторов сравнения могут быть три состояния:

TRUE («истина»)
FALSE («ложь»)
NULL («неопределённое состояние» — когда одно из сравниваемых значений NULL)
С этими тремя состояниями можно проводить следующие логические операции:

AND («И»)
OR («ИЛИ»)
NOT («НЕ»)
Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):

a	   | b	    |  a AND b |a OR b
TRUE |	TRUE	|  TRUE	   |TRUE
TRUE |	FALSE	|  FALSE   |TRUE
TRUE |	NULL	|  NULL	   |TRUE
FALSE|	FALSE	|  FALSE	 |FALSE
FALSE|	NULL	|  FALSE	 |NULL
NULL |	NULL	|  NULL	   |NULL


a	   |  NOT a
TRUE |	FALSE
FALSE|	TRUE
NULL |	NULL
Таким образом, операторы сравнения и логические операции позволяют писать комплексные логические выражения.

Запоминать все эти таблицы и комбинации не обязательно. Вы разберётесь с ними по ходу курса — главное, всегда держите эту памятку под рукой. 

Пример:

Допустим, нам известно, что a=10 и b=5. Тогда следующее логическое выражение вернёт TRUE:

a = 10 OR b > 10



Если же между двумя выражениями выше поставить AND, то результат будет уже FALSE, поскольку b не больше 10:

a = 10 AND b > 10


Также важно понимать, что существуют приоритеты выполнения операций:

умножение и деление (* и /)
сложение и вычитание (+ и -)
операторы сравнения (=, !=, >, <, >=, <=)
NOT
AND
OR
На порядок выполнения операторов также можно влиять с помощью скобок. Выражения, помещённые в скобки, будут иметь наивысший приоритет — всё как в математике.
Подведём итоги
На этом уроке мы:

Познакомились с операторами SELECT и FROM и научились составлять базовые запросы.
Узнали, как сортировать записи с помощью оператора ORDER BY.
Научились ограничивать количество выводимых записей с помощью оператора LIMIT.
Выяснили, как преобразовывать типы данных с помощью CAST.
Научились работать с датой и временем и познакомились с функцией DATE_PART.
Узнали про NULL значения и поработали с COALESCE.
Научились работать с текстовыми данными и соединять строки с помощью функции CONCAT.
Поработали с арифметическими операторами и математическими функциями.
Познакомились с конструкцией CASE и научились составлять комплексные логические выражения.
Известные нам на текущий момент ключевые слова и порядок их написания в запросе:

SELECT    -- перечисление полей результирующей таблицы
FROM      -- указание источника данных
ORDER BY  -- сортировка результирующей таблицы
LIMIT     -- ограничение количества выводимых записей

Задача 1.
Фильтрация данных позволяет включать в результирующий запрос не все строки исходной таблицы, а только те, которые соответствуют заранее заданному условию.

В SQL для фильтрации данных используется оператор WHERE. После оператора WHERE указывается логическое выражение, результат которого определяет, будет ли строка включена в результирующую таблицу. Если условие оказывается истинным (TRUE), то строка включается в результат, если ложным (FALSE) — строка исключается.

Таким образом, каждая строка в таблице проходит проверку на соответствие определённому условию, и в результате этих проверок формируется таблица, над которой затем проводятся операции, указанные в блоке SELECT.

Оператор WHERE и логическое выражение указываются после блока FROM:

SELECT column_1, column_2
FROM table
WHERE column_2 >= 0


Например, в результате указанного выше запроса в выборку попадут только записи с неотрицательными значениями в колонке column_2.

В свою очередь операторы ORDER BY и LIMIT записываются уже после оператора WHERE. Если добавить их в пример выше, то запрос будет выглядеть так:

SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
ORDER BY column_1
LIMIT 100


В результате мы сначала отфильтруем необходимые нам строки, затем выберем столбцы, отмеченные в SELECT, а потом отсортируем результирующую таблицу, ограничив число выводимых записей.

Таким образом, порядок записи известных нам на текущий момент ключевых слов выглядит так:

SELECT
FROM
WHERE
ORDER BY
LIMIT
Снова обратим внимание, что порядок их выполнения отличается от того, в какой последовательности они указываются в запросе:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Далее WHERE — отфильтровываются строки, соответствующие условию.
Затем SELECT — отбираются указанные столбцы и применяются функции.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.
Иными словами, в результате выполнения запроса сначала происходит подготовка таблицы к работе, а уже затем над ней выполняются разные операции.

На заметку:

Подробнее про оператор WHERE можно почитать здесь.

А теперь давайте порешаем задачи на фильтрацию данных и научимся применять оператор WHERE в сочетании с логическими выражениями. Начнём с простого.

Задача 2.
Фильтровать данные в таблицах можно не только по полям с числовыми значениями, но и по полям со значениями, представленными в виде текста:

SELECT column_1, column_2
FROM table
WHERE column_2 = 'text'


В примере выше в результирующую таблицу попадут только строки, значения в которых полностью совпадают с указанной в WHERE строкой 'text'. 

 При сравнении строк также допускается использовать неравенства:

SELECT column_1, column_2
FROM table
WHERE column_2 > 'text'


Впрочем, такая операция используется реже, поскольку не вполне очевидно, что означает «одна строка больше другой».

На самом деле порядок сортировки данных строкового типа обычно определяется заранее установленными правилами сортировки, при которых значение имеют длина строки в символах, порядок букв в соответствии с алфавитом, наличие особых символов, регистр и т.д. Мы не будем подробно останавливаться на этой теме — при желании об этом можно дополнительно прочитать в документации.

На заметку:

Подробнее о правилах сортировки данных строкового типа можно почитать здесь.https://www.postgresql.org/docs/current/collation.html

В качестве значений для фильтрации можно также использовать даты и время:

SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31'


SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31 00:00:00'


Однако при этом важно заранее убедиться, что в колонке, по которой будут фильтроваться данные, находятся именно даты или отметки времени, а не данные строкового типа, внешне похожие на даты. Если в колонке окажутся строки, то как таковой ошибки не произойдёт, однако результат будет сильно отличаться от ожидаемого.

Также в операциях сравнения дат важно учитывать, что дата всегда интерпретируется как полночь (начало дня), т.е. '2022-12-31' в действительности означает '2022-12-31 00:00:00'.

Кстати, ничто не запрещает нам комбинировать в блоке WHERE разные условия с разными типами данных и создавать более сложные логические выражения:

SELECT column_1, column_2, column_3
FROM table
WHERE column_1 >= 0 
      AND column_2 = 'some text' 
      AND column_3 = '2022-12-31'


Давайте как раз решим задачу сразу с несколькими условиями!

Задача 4.
В операторе WHERE можно использовать не только колонки, которые уже есть в таблице, но в том числе и расчётные колонки. При этом указывать их в SELECT опять же не обязательно: 

SELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average
FROM table
WHERE (column_1 + column_2) * 0.5 = 10


SELECT column_1, column_2
FROM table
WHERE (column_1 + column_2) * 0.5 = 10 


В примере выше мы отфильтруем только те записи, для которых среднее арифметическое двух чисел, которые содержатся в колонках column_1 и column_2, будет равно 10.

Также важно учитывать, что использовать в блоке WHERE алиасы, присвоенные новым расчётным колонкам, нельзя. Обратите внимание на примеры следующих запросов, которые считают долю значений из колонки column_1 в соответствующих им значениях из колонки column_2. Первый запрос сработает, а второй вернёт ошибку:

-- Этот запрос сработает:

SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE column_1 / column_2 > 50


-- Этот запрос вернёт ошибку:

SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE share > 50


Это связано со всё той же последовательностью выполнения операторов в запросе: на момент выполнения оператора WHERE алиас колонке ещё не присвоен, и поэтому база данных пока не знает о существовании колонки с новым именем.

Можно рассмотреть ещё более тривиальный пример: даже если мы просто сделаем дубликат колонки с другим именем и попробуем использовать это имя в WHERE, то всё равно получим ошибку:

-- Этот запрос вернёт ошибку:
SELECT column, column AS same_column
FROM table
WHERE same_column > 0


При указании фильтров в блоке WHERE важно учитывать рассмотренные особенности. Можете руководствоваться следующим правилом: если собираетесь фильтровать данные по расчётной колонке, то дублируйте расчёты в WHERE и не используйте алиасы, присвоенные новым колонкам.

Задание:

Назначьте скидку 20% на все товары из таблицы products и отберите те, цена на которые с учётом скидки превышает 100 рублей. Выведите id товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите old_price, с новой — new_price.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price

Пояснение:

Будьте внимательны, когда будете указывать фильтр после оператора WHERE.

Задача 5.
После оператора WHERE к колонкам можно также применять разные функции:

SELECT column_1, column_2
FROM table 
WHERE LOWER(column_1) = 'karpov.courses'


В примере выше каждое значение в колонке column_1 сначала будет приведено к нижнему регистру, а затем сопоставлено со значением 'karpov.courses'. При этом в результат будут включены исходные значения в колонке column_1. Таким образом, функция послужит только для фильтрации записей, но на сами значения в колонках никак не повлияет.

Обратите внимание, что использовать алиасы, присвоенные колонкам в операторе SELECT, всё так же нельзя. Следующий запрос вернёт ошибку:

-- Этот запрос вернёт ошибку:

SELECT column_1 AS new_column_1, column_2
FROM table 
WHERE LOWER(new_column_1) = 'karpov.courses'


Задание:

Отберите из таблицы products все товары, названия которых либо начинаются со слова «чай», либо состоят из пяти символов. Выведите две колонки: id товаров и их наименования.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name

Пояснение:

Для решения задачи вам пригодятся функции SPLIT_PART и LENGTH, которые мы рассматривали на прошлом уроке.

Задача 6.
Представьте, что из общего списка наименований товаров нам вдруг понадобилось отобрать определённые позиции, содержащие определённые слова или даже символы. Но при этом мы точно не знаем, в какой части наименования их можно встретить.

Например, нам нужны все «чаи», но они необязательно должны начинаться со слова «чай». Нам также подойдёт «иван-чай» или какой-нибудь «чайный напиток».

Но как это сделать? Неужели нам придётся просматривать всю таблицу, вручную составлять список товаров и писать длинное логическое выражение, учитывающее все возможные сценарии?

Разумеется, не придётся. Для фильтрации по колонкам с текстовыми значениями в SQL предусмотрен оператор LIKE.

Оператор LIKE не просто сравнивает строки на полное совпадение (или несовпадение), а проверяет их на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE, в противном случае — FALSE.

Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ). Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:

SELECT 'karpov.courses' LIKE 'karpov%'

Результат:
true

SELECT 'karpov.courses' LIKE 'karpov_'

Результат:
false

SELECT 'karpov.courses' LIKE '%karpov%'

Результат:
true

SELECT 'karpov.courses' LIKE '_karpov%'

Результат:
false

SELECT 'karpov.courses' LIKE '%.%'

Результат:
true

SELECT 'karpov.courses' LIKE '_._'

Результат:
false

SELECT 'karpov.courses' LIKE 'Karpov%'

Результат:
false


Обратите внимание на последний пример: оператор LIKE чувствителен к регистру. Для проверки соответствия строки шаблону символов без учёта регистра можно использовать оператор ILIKE:

SELECT 'KARPOV.COURSES' LIKE '%karpov%'

Результат:
false

SELECT 'KARPOV.COURSES' ILIKE '%karpov%'

Результат:
true


Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет собой строку и LIKE работает как оператор сравнения, проверяя строки на точное совпадение.

SELECT 'karpov.courses' LIKE 'karpov.courses'

Результат:
true

SELECT 'karpov.courses' LIKE 'karpov'

Результат:
false


Как можно догадаться, конструкция NOT LIKE работает с точностью до наоборот, инвертируя результат работы оператора LIKE:

SELECT 'karpov.courses' NOT LIKE '%kasparov%'

Результат:
true

SELECT 'karpov.courses' NOT LIKE '%karpov%'

Результат:
false


На заметку:

Подробнее про оператор LIKE и шаблоны можно почитать здесь.

Задание:

Отберите из таблицы products все товары, содержащие в своём названии последовательность символов «чай» (без кавычек). Выведите две колонки: id продукта и его название.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name

Задача 9.
Но что если мы всё-таки не хотим проверять наши данные на соответствие какому-то шаблону, а просто хотим отобрать значения из некоторого списка или даже диапазона? В этом случае в логическом выражении после ключевого слова WHERE можно использовать операторы IN и BETWEEN.

Оператор IN проверяет, соответствует ли значение в колонке одному из значений из заданного списка. Иными словами, он проверяет, входит ли значение в этот список:

SELECT column_1, column_2
FROM table
WHERE column_1 IN ('product_1', 'product_2', 'product_3')


В свою очередь оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу. При этом границы интервала включаются:

SELECT column_1, column_2
FROM table
WHERE column_2 BETWEEN 5 AND 10


Запрос выше равносилен следующему запросу:

SELECT column_1, column_2
FROM table
WHERE column_2 >= 5 AND column_2 <= 10


Оператор BETWEEN можно использовать и для фильтрации по колонкам с датами и временем:

SELECT column_1, column_2, column_3
FROM table
WHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'


Однако в этом случае снова нужно учитывать, что дата всегда интерпретируется как полночь (начало дня), т.е. '2022-12-31' в действительности означает '2022-12-31 00:00:00'. Поэтому в заданный выше интервал не попадут записи позже полуночи '2022-12-31', т.е. этот день практически не будет учтён в интервале.

При этом запрос выше будет равносилен следующему запросу:

SELECT column_1, column_2, column_3
FROM table
WHERE column_3 >= '2022-11-20' AND column_3 <= '2022-12-31'


Для получения обратного результата в сочетании с операторами IN и BETWEEN можно использовать оператор NOT:

SELECT column_1, column_2
FROM table
WHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')


SELECT column_1, column_2
FROM table
WHERE column_2 NOT BETWEEN 5 AND 10


На заметку:

Подробнее про операторы IN и BETWEEN можно прочитать здесь и здесь.

Задача 10.
На прошлом уроке мы столкнулись с пропущенными значениями в таблице couriers — у некоторых курьеров не были указаны их дни рождения.

Для проверки на NULL значения в SQL есть оператор IS NULL. В сочетании с WHERE записывается он так:

SELECT column_1, column_2
FROM table
WHERE column_1 IS NULL


Если же, наоборот, необходимо отобрать не NULL значения, то дополнительно используется оператор NOT:

SELECT column_1, column_2
FROM table
WHERE column_1 IS NOT NULL


Как мы уже знаем, в мире данных NULL означает отсутствие информации. NULL — это не какая-то величина, и поэтому её нельзя сравнить с чем-либо ещё. Результатом сравнения NULL с любым другим значением будет тот же NULL. Более того, NULL не получится сравнить и с другим NULL, потому что в таком случае будут сравниваться две неопределённости и нельзя наверняка сказать, равны они или нет.

Попробуйте самостоятельно запустить в Redash следующие запросы и посмотрите на их результат:

SELECT NULL = NULL

Результат:
NULL

SELECT NULL IS NULL

Результат:
true

SELECT 100 = NULL

Результат:
NULL

SELECT 100 IS NULL

Результат:
false


На заметку:

Подробнее про NULL значения можно прочитать здесь.

Подведём итоги
В этом уроке мы:

Научились фильтровать данные и применять логические выражения в блоке WHERE.
Выяснили, что фильтрацию можно делать сразу по расчётным полям с применением функций к колонкам.
Разобрались, как задавать шаблоны для текстовых значений с помощью оператора LIKE.
Познакомились с операторами IN и BETWEEN.
Узнали ещё больше о NULL значениях и научились отфильтровывать их с помощью IS NULL.
Поработали с датами и временем и научились задавать диапазоны значений.
Совместили новые знания с информацией из прошлого урока и решили большую задачу на CASE.
Известные нам на текущий момент ключевые слова и порядок их написания в запросе:

SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

Задача 1.
На лекции мы познакомились с ключевым словом DISTINCT. Перед тем как переходить к задачам на агрегацию, давайте сперва разберёмся, как его использовать.

Ключевое слово DISTINCT позволяет отбирать уникальные записи, т.е. избавляться от всех дубликатов в таблице.

Указывается DISTINCT сразу после SELECT. Для вывода уникальных значений в одной колонке можно составить следующий запрос:

SELECT DISTINCT column
FROM table


Давайте для начала решим простую задачу.

Задача 2.
Ключевое слово DISTINCT можно применять не только к одной колонке, но и сразу к нескольким.

Например, запрос для двух колонок будет выглядеть так:

SELECT DISTINCT column_1, column_2
FROM table


В таком случае в качестве результата запрос вернёт уникальные комбинации значений в колонках.

Задача 3.
Ну что же, с DISTINCT мы разобрались, теперь перейдём к агрегирующим функциям. 

Агрегирующими функциями называют функции, которые обрабатывают определённый набор строк и возвращают одно обобщающее значение. Если вы когда-нибудь работали в Excel, то наверняка сталкивались с подсчётом суммы или максимального/минимального значения по столбцу — речь идёт именно об этом.

Вот несколько примеров таких функций в SQL:

COUNT — считает количество значений в колонке.
SUM — вычисляет сумму значений.
AVG — вычисляет среднее значение.
MAX — вычисляет максимальное значение.
MIN — вычисляет минимальное значение.
Пример:

SELECT COUNT(column) AS count
FROM table


SELECT SUM(column_1) AS sum,
       AVG(column_2) AS average
FROM table


Обратите внимание, что некоторые из вышеуказанных функций нельзя применять к колонкам с текстом, датами и временем, поскольку не вполне понятно, что, например, означает найти среднее значение или сумму наименований товаров.

В то же время «максимальное» наименование товара вычислить можно — функция MAX будет искать наибольшее значение в упорядоченной последовательности (в соответствии с установленными правилами сортировки значений строкового типа).

Впрочем, заучивать границы применимости этих функций не нужно — просто руководствуйтесь здравым смыслом.

На заметку:

Подробнее с агрегирующими функциями можно ознакомиться здесь.

В документации PostgreSQL есть и более специфические функции, но списка выше на первое время нам точно хватит.

Задача 4.
Также при подсчёте количества записей иногда вместо наименования колонки в качестве атрибута функции COUNT используют звёздочку «*»:

SELECT COUNT(*)
FROM table


Однако важно учитывать один нюанс: запрос со звёздочкой возвращает количество вообще всех записей в таблице, а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.

Таким образом, если в некоторой колонке column есть пропуски, выражения COUNT(*) и COUNT(column) вернут разные значения.

Давайте это проверим!
Задача 5.
И ещё один важный момент: агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям.

Если в случае с MIN и MAX это не имеет особого смысла, то при расчёте AVG, SUM и COUNT иногда это бывает полезно:

SELECT SUM(DISTINCT column) AS sum_distinct
FROM table


При этом довольно часто DISTINCT используется именно в сочетании с COUNT — для подсчёта числа уникальных пользователей, уникальных заказов и т.д.

SELECT COUNT(DISTINCT column) AS count_distinct
FROM table


Этим мы с вами и займёмся!
Задача 6.
А что если для расчётов нам нужны не все данные в столбце, а только какая-то часть? Тогда в запрос с агрегирующими функциями можно включить оператор WHERE, указав условие для отбора записей:

SELECT COUNT(column_1) AS count
FROM table
WHERE column_2 > 100


В таком случае сначала будет выполнена фильтрация таблицы и только потом будет произведена агрегация по оставшимся записям.

На всякий случай напомним порядок выполнения в запросе известных нам ключевых операторов:

FROM       -- выбор источника данных
WHERE      -- фильтрация данных
SELECT     -- перечисление полей результирующей таблицы и проведение расчётов
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей


Теперь давайте совместим фильтрацию и агрегацию в одном запросе и решим пару несложных задач.
Задача 9.
Теперь решим ещё одну задачу и заодно познакомимся с новой функцией array_length.

Как вы помните, в таблице orders содержимое заказов представлено в виде списков товаров (массивов). Чтобы посчитать количество товаров в каждом заказе, можно как раз воспользоваться функцией array_length.

Функция array_length вычисляет количество элементов в массиве (длину массива) и записывается следующим образом:

SELECT array_length(ARRAY[1,2,3], 1)

Результат:
3


Синтаксис может показаться вам немного сложным, но это только на первый взгляд! Давайте разбираться. 

ARRAY[1,2,3] — это некоторый список из трёх значений: 1, 2 и 3.

Единица в качестве второго аргумента — это размерность массива, по которой считается его длина. Так как список у нас одноразмерный (просто значения, записанные в одну строчку), то выбор у нас невелик — можем указать только первую размерность.

Если бы у нас была таблица N x N, в которой были бы и строки, и столбцы, то размерности было бы две: первая соответствовала бы количеству строк, а вторая — числу столбцов. В таком случае мы могли бы указать либо первую, либо вторую размерность.

Давайте представим, что у нас есть простая таблица следующего вида:

 _______
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
 ‾‾‾‾‾‾‾


В этой таблице 3 строки и 2 столбца, поэтому её можно описать в виде следующего списка из трёх вложенных в него списков:

ARRAY[[1,2], [3,4], [5,6]]


В примере выше количество списков внутри основного списка — это количество строк в таблице, а количество элементов внутри каждого внутреннего списка — это количество столбцов.

Обратите внимание на результат вычислений функции array_length для первой и второй размерностей:

SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)

Результат:
3

SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)

Результат:
2


Можете самостоятельно запустить в Redash указанные выше запросы и изучить полученные результаты.

В это довольно сложно поверить, но значениями в ячейках основной таблицы действительно могут быть другие таблицы (матрицы). К счастью, у нас не такие данные, поэтому мы будем работать с простыми одноразмерными списками значений.

Разумеется, в качестве аргумента функции array_length на месте массива можно указывать имя колонки, которая содержит массивы (в нашем случае это колонка product_ids):

SELECT array_length(column, 1)
FROM table

Задача 10.
В качестве аргумента агрегирующих функций могут выступать не только столбцы, но также расчётные колонки или результат другой функции:

SELECT AVG(some_function(column))
FROM table


SELECT AVG(column_1 + column_2)
FROM table


Давайте попробуем рассчитать средний возраст пользователей мужского пола. Для этого воспользуемся новой для нас функцией AGE.

Функция AGE возвращает разницу между двумя значениями, представленными в формате TIMESTAMP. При этом из первого значения вычитается второе, а сама разница получается в формате INTERVAL:

SELECT AGE('2022-12-12', '2021-11-10')

Результат:
397 days, 0:00:00


Таким образом, с '2021-11-10' по '2022-12-12' прошло ровно 397 дней.

Если в качестве первого аргумента не указать ничего, то на место первой даты автоматически подставится текущая дата (полночь текущего дня, т.е. начало дня).

Если сегодня '2022-12-12', то с '2021-11-10' прошло ровно столько же дней, сколько в примере выше:

SELECT AGE(TIMESTAMP '2021-11-10')

Результат:
397 days, 0:00:00


На самом деле текущей дате соответствует значение current_date, которое можно указывать в качестве аргумента функции AGE: 

SELECT AGE(current_date, '2021-11-10')

Результат:
397 days, 0:00:00


Можете самостоятельно запустить два запроса — с current_date и без — и сравнить полученные результаты. В вашем случае это будут новые результаты, но они должны совпасть.

А само значение current_date можно вызвать так:

SELECT current_date

Результат:
12/12/22	


И ещё один нюанс: чтобы результат отображался не в виде количества дней, а в более удобном формате, можно переводить результат вычислений в тип VARCHAR:

SELECT AGE(current_date, '2021-11-10')::VARCHAR

Результат:
1 year 1 mon 2 days

Задача 11.
Аргументом агрегирующей функции может быть и более сложная расчётная колонка — например, полученная в результате работы конструкции CASE.

В таком случае сама конструкция CASE помещается внутрь скобок агрегирующей функции:

AVG(
    CASE  
    WHEN logical_expression_1 THEN expression_1
    WHEN logical_expression_2 THEN expression_2
    ELSE expression_else
    END
)


Так, если бы в нашей таблице все товары были разбиты по категориям и мы захотели бы посчитать среднюю цену товаров с учётом повышающих или понижающих коэффициентов для каждой категории, то мы могли бы сделать это, например, следующим образом:

SELECT AVG(
    CASE 
    WHEN category='мясо' THEN price*0.95
    WHEN category='рыба' THEN price*0.9
    WHEN category='напитки' THEN price*1.05
    ELSE price
    END
    ) AS avg_price
FROM products


Давайте усложним одно из предыдущих заданий и рассчитаем стоимость ещё одного заказа.
Задача 12.
Мы рассмотрели несколько примеров, когда в качестве аргумента агрегирующих функций выступает результат выполнения другой функции.

Но агрегирующая функция может и сама оказаться на месте аргумента какой-то функции:

SELECT some_function(SUM(column)) AS result
FROM table


Наглядный пример — применение функции ROUND к результату агрегации:

SELECT ROUND(SUM(column)) AS rounded_sum
FROM table


Давайте решим похожую задачу и заодно ненадолго вернёмся к нашим напиткам и оператору LIKE.
Задача 13.
Впрочем, бывают и случаи, когда в качестве аргументов некоторой функции выступают сразу несколько агрегирующих функций:

SELECT some_function(SUM(column_1), SUM(column_2)) AS result
FROM table


Например, нам уже знакома функция AGE, которая может принимать сразу два аргумента — дату конца и дату начала некоторого периода времени.

Задача 14.
А теперь рассмотрим пример, когда агрегирующая функция принимает в качестве аргумента одну функцию и при этом сама является аргументом другой функции.

Выглядеть это может так:

SELECT function_two(SUM(funtion_one(column))) AS result
FROM table


В этом примере сначала к колонке column применится функция function_one, затем с помощью функции SUM будет посчитана сумма полученных значений, и только потом к результату агрегации применится функция function_two.
Задача 15.
Результаты нескольких агрегирующих функций можно использовать в одном запросе для проведения над ними арифметических операций:

SELECT (SUM(column_1) + SUM(column_2)) / 2
FROM table


Например, в запросе выше будет посчитано среднее арифметическое двух сумм — значений в колонке column_1 и значений в колонке column_2.

Если после агрегирующей функции указать ключевое слово FILTER и поместить в скобках некоторое условие condition после WHERE, то агрегирующей функции на вход будут поданы только те строки, для которых условие фильтра окажется истинным.

В общем виде эта конструкция выглядит так:

SELECT agg_function(column) FILTER (WHERE condition)
FROM table


Например, если бы мы захотели посчитать среднюю цену только для товаров категории 'рыба', то запрос выглядел бы так:

SELECT AVG(price) FILTER (WHERE category = 'рыба') AS avg_fish_price
FROM table


Обратите внимание: это очень похоже на обычную фильтрацию с агрегацией, которую мы рассматривали в предыдущих задачах, только в данном случае условие на отбор записей указывается сразу в блоке SELECT.

Преимущество такой записи в том, что она позволяет проводить расчёты без промежуточных запросов с условиями в блоке WHERE.

Рассмотрим ещё один пример.

В нашем случае довольно понятно, как посчитать общее количество пользователей. Также вроде бы понятно, как посчитать количество пользователей, которые хотя бы раз отменяли заказ — достаточно просто указать нужное условие в операторе WHERE. Но как в рамках одного запроса посчитать тех, кто никогда не отменял свой заказ?

Поскольку объединять несколько запросов вместе мы пока не умеем, на помощь нам может прийти агрегатное выражение.

Подведём итоги
В этом уроке мы:

Познакомились с ключевым словом DISTINCT.
Разобрались, как работают агрегирующие функции SUM, MIN, MAX, COUNT, AVG.
Узнали разницу между COUNT(*) и COUNT(column).
Научились совмещать фильтрацию и агрегацию в одном запросе.
Поработали с массивами и узнали, что делает функция array_length.
Узнали ещё больше про даты и время и познакомились с функцией AGE.
Затронули более продвинутую тему — агрегатные выражения с фильтрацией.
Известные нам на текущий момент ключевые слова и порядок их написания в запросе:

SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей


Впереди ещё много интересного!
Задача 1. 
В лекции мы познакомились с оператором GROUP BY и составили несколько базовых запросов с группировкой.

Давайте на всякий случай ещё раз уточним логику, которая стоит за этой операцией:

Сначала в таблице определяются строки, в которых в указанном в GROUP BY столбце есть одинаковые значения.
Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.
После этого с помощью агрегирующих функций над элементами этих групп, как правило, проводятся определённые операции. Например, с помощью SUM вычисляется сумма значений в каком-либо столбце в каждой группе:
SELECT column_1, SUM(column_2) AS sum
FROM table
GROUP BY column_1


4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка. При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.

А теперь сделаем несколько важных уточнений.

— Во-первых, группировку можно делать сразу по нескольким колонкам:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


В таком случае количество групп в результирующей таблице будет равно числу уникальных комбинаций значений в нескольких столбцах, указанных в GROUP BY. При этом для каждой такой группы будет проведена агрегация значений по колонке, указанной в качества аргумента агрегирующей функции.

— Во-вторых, к группам, образовавшимся в результате GROUP BY, можно применять сразу несколько агрегирующих функций (в том числе к разным колонкам):

SELECT column_1, SUM(column_2) AS sum, AVG(column_3) AS avg
FROM table
GROUP BY column_1


При этом агрегирующую функцию можно применить к той же самой колонке, по которой осуществляется группировка:

SELECT column_1, COUNT(column_1) AS count
FROM table
GROUP BY column_1


Не всегда такая операция имеет смысл, но она допустима. Например, с помощью функции COUNT можно посчитать количество записей, попавших в каждую группу.

— В-третьих, после группировки к результатам агрегирующих функций можно применять другие функции. Также над ними можно сразу проводить арифметические операции:

SELECT column_1, ROUND(SUM(column_2), 2) AS rounded_sum
FROM table
GROUP BY column_1


SELECT column_1, SUM(column_2)::DECIMAL / SUM(column_3) * 100 AS share
FROM table
GROUP BY column_1


— В-четвёртых, агрегацию не обязательно проводить по уже имеющимся колонкам — можно сначала применить некоторую функцию в колонке из исходной таблицы, а затем сразу провести агрегацию по новой колонке:

SELECT column_1, SUM(some_function(column_2)) AS sum_over_function
FROM table
GROUP BY column_1


— В-пятых, группировку можно делать сразу по новым полям, посчитанным в SELECT. При этом допускается использование в GROUP BY алиаса колонки, указанного в SELECT.

Например, если нам необходимо сгруппировать данные по дням, выделив дату из какой-то колонки, и посчитать сумму некоторых значений в каждый из дней, то можно использовать следующие запросы, которые дадут одинаковый результат:

SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY DATE(column_1)


SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY date


Важно: несмотря на то, что в соответствии с порядком выполнения операторов блок SELECT выполняется после блока GROUP BY, в данном случае PostgreSQL позволяет нам немного отойти от правил и упростить процесс написания запроса. Однако такой «синтаксический сахар» есть не в каждой СУБД, поэтому при работе с другими инструментами будьте аккуратны — в общем случае рекомендуется дублировать расчётное поле в блоке GROUP BY и не использовать в нём алиасы колонок из SELECT.

— В-шестых, делать агрегацию после группировки не обязательно. Если не указать агрегирующую функцию, то запрос вернёт уникальные значения в столбце (или уникальные комбинации значений в столбцах), т.е. тот же результат, что и оператор DISTINCT. Можете самостоятельно запустить следующие запросы в Redash и убедиться:

SELECT user_id
FROM user_actions
GROUP BY user_id


SELECT DISTINCT user_id
FROM user_actions


Кстати, вопрос о том, какими способами можно отобрать уникальные значения в столбце, часто встречается на собеседованиях.

— В-седьмых, при использовании группировки колонки, указанные в SELECT, должны находиться и в GROUP BY, если они не используются в агрегирующих функциях.

Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.

Следующий запрос работать не будет, так как в GROUP BY указаны не все неагрегированные колонки из блока SELECT: 

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1


То есть в запросе выше мы сгруппировали данные по колонке column_1, но при этом попросили базу данных вывести группировку по колонкам column_1 и column_2 с расчётом суммы некоторых значений в колонке column_3. Так делать нельзя.

В данном случае правильным был бы следующий запрос:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


Обратите внимание, что в обратную сторону указанное выше правило не работает: если мы что-то указали в GROUP BY, то это совсем не обязательно указывать в SELECT. Иными словами, можно не выводить наименования колонок, по которым осуществляется группировка.

Например, в этом запросе в блоке SELECT нет колонки, указанной в GROUP BY. Тем не менее такой запрос всё равно сработает:

SELECT SUM(column_2) AS sum
FROM table
GROUP BY column_1


Дело в том, что сама группировка всегда происходит до выполнения блока SELECT, где мы по сути указываем, что включить в результат. То есть даже если мы не укажем колонку в SELECT, но укажем её в GROUP BY, группы всё равно будут сформированы, но их наименования просто не будут включены в результирующую таблицу.

— И наконец, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в WHERE и только потом данные группируются с помощью GROUP BY:

SELECT column_1, SUM(column_2) AS sum
FROM table
WHERE column_3 > 0
GROUP BY column_1


Таким образом, порядок записи ключевых слов выглядит так:

SELECT
FROM
WHERE
GROUP BY
ORDER BY
LIMIT
В то же время порядок выполнения операторов в запросе следующий:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Далее WHERE — отфильтровываются строки, соответствующие условию.
Потом GROUP BY — строки объединяются в группы и производится агрегация.
Затем SELECT — отбираются указанные столбцы.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.
И ещё: вместо названий колонок в блоке GROUP BY можно использовать порядковые номера колонок, указанных в SELECT. Например, следующие запросы эквивалентны:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY 1, 2


При этом номера колонок из SELECT можно также использовать при сортировке в операторе ORDER BY:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY 1, 2
ORDER BY 3


Можете сами поэкспериментировать с этим функционалом в последующих заданиях.
Задача 3.
С простыми задачами на группировку справились, теперь попробуем сделать кое-что поинтереснее: сгруппируем наши данные не по имеющейся в таблице колонке, а по расчётной.

Чтобы понять, как это работает, просто представьте, что сначала вы создаёте какую-то новую колонку на основе уже имеющейся, применяя к ней какую-то функцию, а потом сразу в этом же запросе производите группировку по новой колонке.

На первом шаге мы уже рассматривали пример с DATE — давайте рассмотрим ещё один:

SELECT UPPER(column_1) AS upper_column, SUM(column_2) AS sum
FROM table
GROUP BY UPPER(column_1)


Здесь мы сначала рассчитали колонку upper_column, применив функцию UPPER к колонке column_1, а затем сразу же сгруппировались по ней, посчитав сумму всех значений в колонке column_2 в каждой группе.

Напомним, что такой вариант запроса тоже сработает:

SELECT UPPER(column_1) AS upper_column, SUM(column_2) AS sum
FROM table
GROUP BY upper_column


А теперь, используя все эти знания, давайте посчитаем, сколько заказов было сделано в каждом месяце. Разумеется, для этого нам потребуется как-то получить месяц из каждой даты. Это можно было бы сделать с помощью функции DATE_PART, но в этот раз для работы с датами мы попробуем новую функцию DATE_TRUNC.

Функция DATE_TRUNC используется для усечения дат и времени, т.е. она работает аналогично округлению ROUND, только для типов данных TIMESTAMP и INTERVAL.

Синтаксис у неё такой же, как и у DATE_PART:

SELECT DATE_TRUNC(part, column)


На месте part в кавычках указывается, до какой точности следует округлять переданное значение времени:  'year', 'month', 'day', 'hour' и т.д.

Возвращаемое значение имеет тип TIMESTAMP или INTERVAL, а все «части» исходного значения, менее значимые, чем заданная «часть», приравниваются к нулю (или единице, если это номер дня или месяца):

SELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')

Результат:
01/01/22 00:00

SELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')

Результат:
12/01/22 00:00	

SELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')

Результат:
12/01/22 08:00	



На заметку:

Подробнее с функцией DATE_TRUNC можно ознакомиться здесь.
Задача 5.
Расчётные колонки можно использовать не только для того, чтобы группировать по ним данные. Их можно также использовать в качестве полей, по которым производится агрегация внутри групп.

Иными словами, агрегацию не обязательно проводить по уже имеющимся колонкам — колонки можно «создавать» в рамках того же запроса, в котором происходит группировка:

SELECT column_1, MIN(DATE_TRUNC('month', column_2)) AS min_month
FROM table
GROUP BY column_1


В примере выше с помощью функции DATE_TRUNC мы сначала привели все даты в колонке column_2 к началу месяца (получив по сути новую колонку), а затем сразу же провели агрегацию по новой колонке, посчитав минимальную округлённую дату в каждой группе, сформированной на основе колонки column_1.

Обратите внимание, что тот же самый результат мы могли бы получить и с помощью такого запроса:

SELECT column_1, DATE_TRUNC('month', MIN(column_2)) AS min_month
FROM table
GROUP BY column_1


Получается, что и к результату агрегирующей функции можно сразу же применять другие функции.

При этом в примерах выше не имеет значения, в каком порядке проводить вычисления: мы можем сначала округлить даты, а затем найти среди них минимальную, или же сначала найти минимальную дату и затем округлить её.

Но нужно быть внимательными: часто результат зависит от того, в каком порядке применяются обычные и агрегирующие функции. Например, следующие два запроса дадут разный результат:

SELECT column_1, MIN(DATE_PART('month', column_2)) AS min_month
FROM table
GROUP BY column_1


SELECT column_1, DATE_PART('month', MIN(column_2)) AS min_month
FROM table
GROUP BY column_1


В первом запросе из каждой даты в колонке column_2 мы сначала выделяем все порядковые номера месяцев, а затем в каждой группе находим среди них минимальный. В то же время во втором запросе сначала определяется минимальная дата в каждой группе, а потом вычисляется порядковый номер месяца в этой дате.

Разумеется, результат может отличаться, поскольку в данных могут быть даты за разные годы — в самом раннем году могут не оказаться даты с некоторыми месяцами, тогда как в более поздних годах даты с этими месяцами будут. Из-за этого и возможна ситуация, когда запросы будут давать разный результат.

Давайте рассмотрим подобные случаи на практике.
Теперь давайте подумаем, как можно избавиться от группы с пропущенным значением возраста — вряд ли наших маркетологов интересует такая категория пользователей.

Но почему эта категория вообще возникла? Дело в том, что мы опять столкнулись с NULL значениями — на этот раз в колонке birth_date. Но NULL значение — это тоже какое-то значение, а значит, из соответствующих строк и была образована группа с пропуском.

Давайте избавимся от этих пропусков перед группировкой, добавив в наш запрос оператор WHERE. Заодно сделаем наш анализ аудитории чуть более детальным: добавим в группировку пол пользователей.

Напомним, что группировка всегда выполняется после фильтрации, а оператор WHERE указывается в запросе перед оператором GROUP BY:

SELECT column_1, SUM(column_2) AS sum
FROM table
WHERE column_3 > 0
GROUP BY column_1
Задача 11.
Но что если в результат группировки и агрегации мы хотим включить не все группы, а только те, для которых выполняется некоторое условие? Например, только те размеры заказов, количество которых выше или ниже определённого значения? Или только те возрастные группы, количество пользователей в которых превышает заданный порог?

Судя по всему, для этого нам необходимо каким-то образом наложить фильтрацию уже поверх группировки. Но, как мы выяснили, оператор WHERE использовать после GROUP BY нельзя. Что же тогда делать?

Специально для таких случаев существует оператор HAVING, который тоже выполняет функцию фильтрации, но работает поверх уже сгруппированных данных.

В этом и заключается ключевое отличие операторов WHERE и HAVING: первый фильтрует записи в таблице перед группировкой и агрегацией, а второй — после. Кстати, это простой, но довольно популярный вопрос на собеседовании по SQL.

Ещё одна важная особенность работы оператора HAVING: в этом блоке нельзя указывать алиасы полей с результатом агрегации из блока SELECT. Дело в том, что в соответствии с порядком выполнения запроса оператор SELECT выполняется после оператора HAVING. Поэтому агрегацию необходимо также указывать и в HAVING.

Например, такой запрос не сработает:

SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING new_column = 100


А такой сработает:

SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING SUM(column_2) = 100


Кроме того, в HAVING не обязательно указывать ту же агрегацию, что и в блоке SELECT, равно как и в SELECT не обязательно указывать агрегацию из HAVING:

SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING AVG(column_3) < 50


Иными словами, в HAVING фильтрация может производиться по результату одной агрегации, а в результирующую таблицу при этом включаться совсем другая агрегация (в том числе по другой колонке).

Впрочем, в SELECT можно вообще ничего не указывать кроме колонки, по которой производится группировка:

SELECT column_1
FROM table
GROUP BY column_1
HAVING SUM(column_2) = 100 AND AVG(column_3) < 50 


Здесь важно понять, что группировка, агрегация и фильтрация групп со всеми расчётами происходят всегда до выполнения инструкций в блоке SELECT, где вы просто определяете, что попадёт в результирующую таблицу.

Таким образом, мы снова можем дополнить список ключевых слов в запросе:

SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
LIMIT
Порядок их выполнения в запросе следующий:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Далее WHERE — отфильтровываются строки, соответствующие условию.
Потом GROUP BY — строки объединяются в группы и производится агрегация.
Затем HAVING — отфильтровываются группы, соответствующие условию.
После этого SELECT — отбираются указанные столбцы.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.
Давайте дополним наш предыдущий запрос оператором HAVING и заодно немного поменяем условие в WHERE: проведём расчёты только для заказов, сделанных по будням.

Для получения наименования дня недели из колонки с датой или отметкой времени можно использовать, например, функцию DATE_PART с параметром 'isodow' либо функцию TO_CHAR с параметром 'Dy':

SELECT TO_CHAR(TIMESTAMP '2022-08-29', 'Dy')

Результат:
Mon


На заметку:

Подробнее про фильтрацию после группировки и оператор HAVING можно почитать здесь.

С функцией TO_CHAR можно ознакомиться тут.

В качестве поля для группировки может выступать и более сложная расчётная колонка — например, результат выполнения условной конструкции CASE:

SELECT 
       CASE 
       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory,
       AVG(price) AS avg_price
FROM table
GROUP BY сategory


Запрос выше сначала поделит все товары на группы, затем сгруппирует их и для каждой группы посчитает среднюю цену всех попавших в неё продуктов.

Получается, что таким образом мы можем дополнительно управлять группировкой наших данных — сначала мы сами задаём правила, по которым определяем принадлежность записей к некоторым категориям, а затем группируем по ним данные и проводим необходимые расчёты.

Обратите внимание: это как раз тот случай, когда PostgreSQL позволяет нам отойти от правил и указать расчётное поле (category) сразу в блоке GROUP BY, хотя в соответствии с порядком выполнения операторов блок SELECT выполняется после группировки.

Давайте с помощью группировки и условной конструкции CASE разобьём наши заказы на группы и посчитаем количество заказов, попавших в каждую.
А теперь попробуем решить задачу посложнее. Для неё нам снова пригодится агрегатное выражение с фильтрацией, которое мы рассматривали на прошлом уроке.

Эту конструкцию можно применять не только ко всей таблице, но и отдельно к каждой группе, сформированной с помощью GROUP BY. В общем виде она будет выглядеть так:

SELECT column_1, agg_function(column_2) FILTER (WHERE condition)
FROM table
GROUP BY column_1


Например, если бы мы захотели посчитать среднюю цену по категориям товаров и учесть только те продукты, которые ещё остались на складе, то запрос выглядел бы так:

SELECT category, AVG(price) FILTER (WHERE product_count > 0) AS avg_price
FROM table
GROUP BY category


Давайте с помощью группировки и агрегатного выражения с фильтрацией определим пользователей, которые чаще остальных отменяли заказы.

Подведём итоги
В этом уроке мы:

Научились группировать данные и узнали разные нюансы работы оператора GROUP BY.
Поработали с агрегирующими функциями и научились применять их к сгруппированным данным.
Узнали, что к результату группировки можно применять фильтрацию с помощью оператора HAVING.
Ещё немного поработали с датами и познакомились с новыми функциями DATE_TRUNC и TO_CHAR.
Решили несколько задач на CASE с группировкой.
Научились применять FILTER и агрегатные выражения с фильтрацией поверх группировки.
Известные нам на текущий момент ключевые слова и порядок их написания в запросе:

SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
GROUP BY   -- группировка данных
HAVING     -- фильтрация данных после группировки
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

Ещё раз о порядке выполнения операторов в SQL-запросах
К текущему уроку мы уже успели познакомиться с основными операторами, которые составляют «скелет» стандартного SQL-запроса: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY и LIMIT.

Мы уже знаем, что порядок их указания в запросе следующий:

SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
GROUP BY   -- группировка данных
HAVING     -- фильтрация данных после группировки
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей


Тем не менее важно помнить, что порядок выполнения операторов в СУБД несколько отличается от порядка их написания в запросе. В упрощённом виде порядок выполнения запроса в PostgreSQL такой:

FROM       -- указание источника данных
WHERE      -- фильтрация данных
GROUP BY   -- группировка данных
HAVING     -- фильтрация данных после группировки
SELECT     -- перечисление полей результирующей таблицы
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей


Таким образом:

Сначала с помощью FROM определяется таблица.
Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — отбираются нужные колонки, расчётным полям присваиваются новые имена и т.д.
Затем результирующая таблица сортируется в соответствии с правилами в ORDER BY.
И наконец срабатывает ограничение на количество строк, указанное в LIMIT.
На самом деле это очень важная информация, которую следует всегда держать в голове при составлении любых SQL-запросов. 

Наверняка вы уже успели столкнуться с ошибками, когда пытались в блоке WHERE использовать фильтрацию по новым полям, рассчитанным в SELECT. Такая операция не соответствует порядку выполнения операторов, и поэтому она недопустима. Также вы уже могли попасть в ситуацию, когда при фильтрации в HAVING не принимался алиас колонки, рассчитанной в SELECT. Это происходило по той же причине — PostgreSQL просто ещё не знала о том, что вы присвоили колонке новое имя.

И ещё один важный совет. Обратите внимание: фильтрацию данных по неагрегированным значениям можно делать как в блоке WHERE, так и в блоке HAVING. Внимательно посмотрите на следующие запросы:

SELECT sex, COUNT(user_id) AS users_count
FROM users
WHERE sex = 'male'
GROUP BY sex


SELECT sex, COUNT(user_id) AS users_count
FROM users
GROUP BY sex
HAVING sex = 'male'


Их результат будет одинаковым — можете убедиться в этом сами.

Однако фильтровать неагрегированные данные рекомендуется именно в блоке WHERE, т.е. заранее. В таком случае вы ещё до группировки убираете из расчётов ненужные вам данные и таким образом не расходуете вычислительные ресурсы на подсчёт значений, которые всё равно будут отфильтрованы вами позже (например, с помощью HAVING).

Это важный момент, касающийся оптимизации SQL-запросов, поэтому рекомендуем вам принять во внимание информацию, представленную на этом шаге.

Итак, на лекции мы познакомились с подзапросами (вложенными запросами) и поняли, что в целом их синтаксис ничем не отличается от синтаксиса обычных запросов, которые мы составляли ранее. Иными словами, подзапрос — это всего лишь запрос внутри другого запроса.

Подзапросы могут применяться в следующих частях основного запроса:

в операторе FROM;
в операторе SELECT (если запрос возвращает один столбец с одним значением);
в операторах WHERE и HAVING (если запрос возвращает один столбец с одним или несколькими значениями);
в операторе CASE при формировании продвинутых условных конструкций.
Но давайте обо всём по порядку.

Прежде всего важно понять, что к результату выполнения подзапроса можно обращаться так же, как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:

SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1


По сути подзапрос — это такая же таблица, только временная. Она формируется в процессе выполнения основного запроса и нигде не сохраняется.

В примере выше сначала будет выполнен подзапрос, который отберёт колонки column_1 и column_2 из таблицы table, а затем уже из образовавшейся таблицы основной запрос выберет колонку column_1.

Важный момент: при использовании подзапроса в блоке FROM сформированной в подзапросе таблице необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает. В примере выше мы обозначили результат подзапроса как subquery_1.

Приведённый пример довольно условный и на практике колонки таким образом отбирать не стоит, но общую идею он должен передавать.

Давайте рассмотрим ещё один пример. Он тоже довольно условный, но должен помочь нам во всём разобраться. Мы уже знаем, что посчитать число пользователей мужского пола можно двумя способами:

SELECT sex, COUNT(user_id) AS users_count
FROM users
WHERE sex = 'male'
GROUP BY sex


SELECT sex, COUNT(user_id) AS users_count
FROM users
GROUP BY sex
HAVING sex = 'male'


Но то же самое можно сделать и с помощью подзапроса:

SELECT sex, users_count
FROM (
    SELECT sex, COUNT(user_id) AS users_count
    FROM users
    GROUP BY sex
) AS subquery
WHERE sex = 'male'


Что же здесь произошло? Всё довольно просто: в подзапросе мы сначала сгруппировали наши данные по полу и посчитали число пользователей в каждой группе, а потом обратились к результату этого подзапроса, как к таблице, и отобрали с помощью WHERE нужную нам группу.

Внутри одного запроса может быть сразу несколько подзапросов. Более того, уровней вложенности может быть тоже несколько:

SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2


В данном случае последовательность работы запроса такая: сначала будет выполнен подзапрос, возвращающий результат subquery_1, затем подзапрос, возвращающий результат subquery_2, и только потом в результат основного подзапроса попадёт колонка column_1. В результате получается что-то похожее на матрёшку, при этом к основной таблице table обращается только самый первый подзапрос subquery_1.

К колонкам из подзапроса можно применять агрегирующие функции — так же, как если бы мы обращались к колонкам исходных таблиц:

SELECT MAX(column_sum) AS max_sum
FROM (
    SELECT column_1, SUM(column_2) AS column_sum
    FROM table
    GROUP BY column_1
) AS subquery_1


Здесь сначала в подзапросе мы сгруппируем данные по колонке column_1, посчитав для каждой группы сумму значений в колонке column_2, а затем уже в основном запросе найдём максимальное значение среди всех сумм.

На самом деле вариантов того, как можно использовать подзапросы, очень много. Это крайне полезный функционал, который позволяет формировать продвинутые запросы со сложной логикой. Кроме того, понимание, как работают подзапросы в блоке FROM, нам особенно пригодится, когда в следующем уроке мы будем учиться объединять таблицы с помощью оператора JOIN.
Решая предыдущую задачу, вы могли задаться вопросами: а что если один и тот же подзапрос будет использоваться в нескольких частях основного запроса? неужели каждый раз придётся дублировать один и тот же подзапрос? а что если уровней вложенности будет несколько? не получится ли тогда слишком сложный и громоздкий запрос, который будет сложно читать?

Для таких случаев в SQL предусмотрен оператор WITH, который позволяет создавать так называемые табличные выражения (CTE, common table expressions).

Табличные выражения — это временные таблицы, существующие только для одного запроса. Их основное предназначение заключается в разбиении сложных запросов на несколько частей.

Табличные выражения создаются так:

WITH 
subquery_1 AS (
    SELECT column_1, column_2
    FROM table
)


После оператора WITH указывается название табличного выражения (в данном случае это subquery_1), а затем после ключевого слова AS в скобках указывается сам запрос, с помощью которого будет формироваться табличное выражение. Затем в основной части запроса к табличному выражению можно обращаться по имени, как к таблице:

WITH 
subquery_1 AS (
    SELECT column_1, column_2
    FROM table
)

SELECT column_1
FROM subquery_1


Сравните запрос выше с запросом из прошлого шага:

SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1


Оператор WITH может содержать несколько табличных выражений, причём к указанным ранее выражениям можно обращаться в последующих выражениях:

WITH 
subquery_1 AS (
    SELECT column_1, column_2, column_3
    FROM table
),
subquery_2 AS (
    SELECT column_1, column_2
    FROM subquery_1
)

SELECT column_1
FROM subquery_2


Это похоже на код программы: сначала вы создаете некоторые переменные, а затем обращаетесь к ним в последующих её частях. Только в данном случае в качестве переменных выступают таблицы.

Можете снова сравнить запрос выше с запросом из прошлого шага:

SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2


Результат обоих запросов будет одинаковым.

Использовать в своих запросах оператор WITH или нет — решать вам, но в некоторых случаях он может упростить работу с кодом запроса. 

Предлагаем вам попробовать применить табличные выражения для решения той же самой задачи.

Ещё одно важное направление применения подзапросов — создание более продвинутых условных выражений в операторах WHERE и HAVING. Но поскольку и в том, и в другом случае синтаксис и назначение подзапросов примерно одинаковые, в этом уроке мы будем рассматривать всё на примере подзапросов в WHERE.

В первую очередь важно понять, что подзапрос, возвращающий одно значение, может использоваться совместно с операторами сравнения.

Иными словами, вы можете составить подзапрос, возвращающий одно значение (как правило, это результат работы агрегирующих функций), а затем сравнить с этим значением (т.е. с подзапросом) все значения в одной из колонок таблицы.

Давайте представим, что нам нужно сравнить значения в каком-то столбце с максимальным, минимальным или средним значением в этом же столбце — такая задача довольно часто встречается на практике. Сделать это в рамках одного запроса точно не получится, поскольку, как мы уже знаем, агрегирующие функции нельзя применять в блоке WHERE.

Первое, что приходит в голову, — написать примерно такой запрос:

SELECT column
FROM table
WHERE column = MAX(column) 


Но по понятным причинам работать он не будет, и база данных сообщит об ошибке.

Однако хотя запрос и некорректный, его логика в целом правильная: нам действительно нужно найти максимальное значение в колонке и сравнить с ним все значения в этой же колонке. Единственное, что мы забыли, когда считали максимальное значение, это обратиться к самой таблице.

Давайте это исправим и перепишем запрос следующим образом:

SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table) 


В результате выполнения такого запроса мы получим все значения в колонке column, равные максимальному значению в этой колонке.

Такой запрос отработает уже без ошибок, так как подзапрос с расчётом максимального значения выполнится первым и вернёт одно значение.

А теперь ещё одна несложная задача.

езультат подзапроса, возвращающего столбец с одним значением, также можно использовать в арифметических операциях:

SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table) - 100


Более того, с помощью подзапросов вы можете брать необходимые вам значения из нескольких разных таблиц и использовать их в качестве переменных внутри основного запроса:

SELECT column
FROM table
WHERE column >= (SELECT MAX(column_1) FROM table_1) - 100
    AND column <= (SELECT MAX(column_2) FROM table_2)


То есть в данном случае результат выполнения подзапроса можно рассматривать как некоторую переменную. Со временем число записей в таблицах может меняться (допустим, появляются новые товары по новым ценам или новые заказы с более поздними датами), и наши подзапросы будут это учитывать, каждый раз заново рассчитывая необходимые нам значения — согласитесь, довольно удобный функционал.

На заметку:

Если же в одном запросе используется несколько разных «переменных» из подзапросов или к одному и тому же подзапросу нужно обращаться несколько раз, тогда имеет смысл вынести эти подзапросы в начало основного запроса в виде табличных выражений в блоке WITH.

WITH 
subquery AS (
    SELECT MAX(column_2)
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 = (SELECT * FROM subquery) 


Обратите внимание на запись со «звёздочкой». Дело в том, что обратиться к этим «переменным» просто по имени табличного выражения не получится — придётся отдельным подзапросом из табличного выражения выбрать рассчитанное значение. Самый простой вариант — написать подзапрос с SELECT * из табличного выражения.

Если «переменных» несколько, то запрос может выглядеть так:

WITH
subquery_1 AS (
    SELECT MAX(column_1)
    FROM table_1
),
subquery_2 AS (
    SELECT MAX(column_2)
    FROM table_2
)


SELECT column
FROM table
WHERE column >= (SELECT * FROM subquery_1) - 100
    AND column <= (SELECT * FROM subquery_2)


Такая запись может показаться громоздкой, но в некоторых случаях, когда одни и те же подзапросы необходимо использовать несколько раз по ходу основного запроса, она может существенно упростить ваш код.
В каких ещё случаях на практике нам может пригодиться подзапрос в операторе WHERE?

Давайте представим, что нам нужно провести какие-нибудь расчёты за последние N дней — скажем, за последнюю неделю. Не будем же мы вручную отсчитывать 7 дней от последней даты в нашей таблице? Разумеется, не будем, так как последняя дата может со временем измениться, когда к нам поступят новые данные. Каждый раз писать новый запрос и считать дату вручную — занятие не для нас.

Для решения такой задачи мы можем сначала с помощью подзапроса вычислить последнюю дату в наших данных, а затем отложить от неё неделю.

Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, можно использовать несложные арифметические операции с датами. Например, от текущей даты можно отнять заданный промежуток INTERVAL:

SELECT NOW() - INTERVAL '1 year 2 months 1 week'

Результат:
10/10/21 19:32


Кстати, NOW — полезная функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой, как и результат запроса выше):

SELECT NOW()

Результат:
17/12/22 19:32


На заметку:

С другими примерами работы с INTERVAL и арифметическими операциями с датами можно ознакомиться здесь.

Про функцию NOW можно дополнительно почитать тут.

Задача 6.
Получается, что в одном из прошлых уроков мы неправильно считали возраст курьеров!

Действительно, тогда мы ничего не знали про подзапросы и в качестве первой даты в функции AGE указывали текущую дату, а не последнюю дату в данных. Давайте исправим это досадное недоразумение, ведь теперь у нас для этого есть все необходимые знания.

Но прежде сделаем небольшое, но важное уточнение: подзапросы могут выступать в качестве аргументов функций, т.е. к результату выполнения подзапросов можно применять функции, принимающие на вход какие-то значения. Так, например, подзапросы можно указывать в качестве аргументов функций CONCAT или COALESCE:

SELECT CONCAT(
              'Начало периода: ', (SELECT MIN(date) FROM table), 
              ' ', 
              'Конец периода: ', (SELECT MAX(date) FROM table)
       )


SELECT COALESCE((SELECT MAX(date) FROM table), NOW())


В таком случае результат выполнения подзапроса будет подставляться в функцию для дальнейших расчётов.

Задание:

С помощью функции AGE и агрегирующей функции снова определите возраст самого молодого курьера мужского пола в таблице couriers, но в этот раз при расчётах в качестве первой даты используйте последнюю дату из таблицы courier_actions.

Чтобы получить именно дату, перед применением функции AGE переведите последнюю дату из таблицы courier_actions в формат DATE, как мы делали в этом задании.

Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип VARCHAR. Полученную колонку со значением возраста назовите min_age.

Поле в результирующей таблице: min_age


Задача 7.
Всё это время мы говорили о подзапросах, возвращающих одно значение в результате применения агрегирующих функций. Теперь рассмотрим случаи, когда подзапрос возвращает несколько значений, и узнаем, как это можно использовать для продвинутой фильтрации данных в таблицах.

Подзапрос, возвращающий несколько значений, может использоваться в блоке WHERE совместно с оператором IN — например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, полученного в результате выполнения подзапроса.

Выглядит это так:

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT column_2 FROM table_2) 


Сначала подзапрос отберёт все значения в колонке column_2 из таблицы table_2, а затем выберет те записи из таблицы table_1, где в колонке column_1 значение совпадает с одним из значений в колонке column_2, полученной в результате подзапроса. Обратите внимание, что использовать DISTINCT в подзапросе необязательно, т.к. на результат основного запроса это никак не повлияет — по большому счёту нет разницы, будут значения в списке уникальными или нет.

При этом запрос выше будет равносилен запросу с табличным выражением:

WITH 
subquery AS (
    SELECT column_2
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT * FROM subquery) 


Снова обратите внимание, что при использовании в операторе WHERE табличного выражения обратиться просто к его имени нельзя — необходимо предварительно выбрать все его записи, т.е. написать подзапрос. При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

Давайте рассмотрим следующий пример.

Из наших данных довольно легко отобрать отменённые заказы — достаточно указать в WHERE нужный фильтр. Но как отобрать созданные, но неотменённые заказы? Это как раз можно сделать с помощью подзапроса или табличного выражения. Давайте попробуем это сделать.

Задача 8.
В начале урока мы отметили, что вложенный запрос может располагаться и после оператора SELECT. Однако тогда результатом подзапроса может быть только одно значение — например, результат применения агрегирующей функции к некоторой колонке:

SELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1
FROM table


В этом примере из таблицы table будет выбрана колонка column_1, и напротив каждого значения в этой колонке будет выведен результат выполнения вложенного запроса, т.е. максимальное значение в колонке. При этом давать алиас результату подзапроса не обязательно.

По сути эта операция равносильно тому, как если бы мы просто проставили одно и то же значение в отдельном столбце, посчитав его вручную:

SELECT column_1, 1500 AS max_column_1
FROM table


Разница заключается в том, что с помощью подзапроса мы делаем это значение динамическим и избавляем себя от необходимости постоянно его обновлять.

Также результаты подзапросов в блоке SELECT можно сразу использовать в вычислениях:

SELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2
FROM table


На практике подзапрос в SELECT может использоваться для того, чтобы сравнить значения в колонке с каким-нибудь одним расчётным значением (из той же или другой таблицы):

SELECT column_1, column_2, column_2 > (SELECT MAX(column_1) FROM table) AS column_3
FROM table


На заметку:

На самом деле для того, чтобы в отдельном столбце вывести расчёты с агрегацией по колонкам в той же таблице, не меняя при этом её структуру, чаще используются не подзапросы, а оконные функции — продвинутый функционал, который мы будем рассматривать в конце первого модуля курса.

Сейчас с помощью имеющихся на данный момент знаний мы попробуем решить задачу, не прибегая к продвинутым инструментам. Можете вернуться к этой задаче после прохождения последнего урока и попробовать решить её с помощью оконных функций.
Задача 9.
Подзапросы также могут использоваться в операторе CASE при формировании сложных условных конструкций. Это бывает полезно, когда необходимо сравнить значения в некотором столбце с одним значением, рассчитанным по той же или другой таблице. Или, например, в случаях, когда для каждой записи в таблице нужно проверить вхождение значения в колонке в определённое множество значений из другой таблицы.

Допустим, у нас есть две таблицы, в которых хранятся почты старых и новых клиентов, и нам необходимо «подтянуть» эту информацию в таблицу c заказами. Сделать это можно так:

SELECT client_id, email, order_id,
    CASE 
    WHEN email IN (SELECT email FROM clients_new)
    THEN 'new'
    WHEN email IN (SELECT email FROM clients_old)
    THEN 'old'
    ELSE 'unknown'
    END AS client_type
FROM orders


Вариантов применения подзапросов в операторе CASE — огромное множество. Давайте применим новые знания на наших данных и попробуем назначить скидку с учетом того, насколько сильно цена на товар отличается от средней цены всех товаров.

Пояснение:

Чтобы перевести значение интервала в минуты, необходимо извлечь из него количество секунд, а затем поделить это значение на количество секунд в одной минуте. Для извлечения количества секунд из интервала можно воспользоваться следующей конструкцией:

SELECT EXTRACT(epoch FROM INTERVAL '3 days, 1:21:32')

Результат:
264092	


Функция EXTRACT работает аналогично функции DATE_PART, которую мы рассматривали на прошлых уроках, но имеет несколько иной синтаксис. Попробуйте воспользоваться функцией EXTRACT в этой задаче.

Давайте ненадолго отвлечёмся от подзапросов и снова поработаем с массивами. Заодно освоим продвинутую функцию unnest, которая пригодится нам в дальнейших задачах.

Функция unnest предназначена для разворачивания массивов и превращения их в набор строк:

SELECT unnest(ARRAY['one','two','three'])

Результат:
one
two
three


Развернуть массив означает превратить его в набор записей, где каждой строчке будет соответствовать значение, входящее в массив.

В примере выше функция unnest превратила исходный список из трёх элементов в набор из трёх строк.

Если бы в исходной таблице помимо списка был столбец с каким-либо значением, то это значение автоматически проставилось бы напротив значений в каждой образовавшейся строке:

SELECT 'row', unnest(ARRAY['one','two','three'])

Результат:
row    one
row    two
row    three


В нашем случае мы имеем таблицу с id заказов и списками id товаров, входящих в заказ. Допустим, таблица выглядит так:

 ________________________
| order_id | product_ids |
|__________|_____________|
| 1001     | [5, 8, 15]  |
| 1002     | [2]         |
| 1003     | [4, 11, 21] |
 ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾


Если развернуть массивы в колонке product_ids, то записей с id каждого заказа станет ровно столько, сколько было товаров в массиве, соответствующем эту заказу. Внимательно посмотрите на результат запроса применения функции unnest к колонке product_ids:

SELECT order_id, unnest(product_ids) AS product_id
FROM orders


Результат:
 ________________________
| order_id | product_id  |
|__________|_____________|
| 1001     | 5           |
| 1001     | 8           |
| 1001     | 15          |
| 1002     | 2           |
| 1003     | 4           |
| 1003     | 11          |
| 1003     | 21          |
 ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾


На заметку:

Дополнительные примеры использования функции unnest можно найти здесь.

А теперь попробуем самостоятельно применить функцию unnest к нашим данным.


Основные типы объединений JOIN
Вот мы и подобрались к одной из важнейших тем в SQL — объединению таблиц. 

SQL-запросы позволяют выбирать и обрабатывать данные не только из одной таблицы — в этом мы уже убедились, когда работали с подзапросами. Но таблицы можно также объединять в один результирующий набор записей, связывая их по определённым условиям. Это позволяет делать операция соединения JOIN.

В этом уроке мы рассмотрим следующие типы соединений таблиц:

INNER JOIN
LEFT/RIGHT JOIN
FULL JOIN
CROSS JOIN
Операторы соединения включаются в раздел FROM запроса. В общем виде, вне зависимости от того, какой тип соединения используется, запрос на объединение таблиц выглядит следующим образом:

SELECT ...
FROM table_1 
     JOIN table_2
     ON [condition]
...


Как правило (но далеко не всегда), в качестве условия [condition], по которому происходит объединение, выступает равенство значений в определённых столбцах. В качестве таких столбцов обычно используются ключи с указанием id (товара, пользователя и т.д.), то есть значений, по которым можно однозначно идентифицировать определённую сущность:

SELECT table_1.column_1, table_2.column_2
FROM table_1 
     JOIN table_2
     ON table_1.id = table_2.id
...


При этом у каждой колонки рекомендуется через точку указывать имя таблицы, которая содержит эту колонку. Более того, это становится уже не рекомендацией, а необходимостью, когда имена столбцов в таблицах совпадают — без явного указания источников база данных не сможет сама определить, какие столбцы и в каких таблицах вы имеете в виду, и в результате вернёт ошибку.

Если имена таблиц слишком длинные, таблицам можно присвоить алиасы. По этим же алиасам можно сразу удобно обращаться к колонкам:

SELECT a.column_1, b.column_2
FROM table_1 a 
     JOIN table_2 b
     ON a.id = b.id
...


Если имя поля, по которому происходит объединение, совпадает в обеих таблицах (как в примерах выше), то можно использовать сокращенную запись c оператором USING:

SELECT a.column_1, b.column_2
FROM table_1 a 
     JOIN table_2 b
     USING (id)
...


При объединении таблиц можно также использовать подзапросы. Их можно объединять с другими таблицами или друг с другом:

SELECT ...
FROM table_1
     JOIN (
          SELECT ...
          FROM table_2
     ) AS subquery
    ON table_1.id = subquery.id
...


SELECT ...
FROM (
     SELECT ...
     FROM table_1
) AS subquery_1
     JOIN (
          SELECT ...
          FROM table_2
     ) AS subquery_2
    ON subquery_1.id = subquery_2.id
...


Хорошо, с записью в общем виде вроде бы понятно. Но что же на самом деле происходит при объединении таблиц? Давайте разбираться.

Процесс объединения можно представить в виде следующей последовательности операций:

Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы. т.е. происходит декартово произведение двух множеств, результатом которого является новое множество, состоящее из всевозможных пар исходных строк. Например, если в одной таблице было 50 записей, а в другой 10, то в результате декартова произведения получится 500 записей. На игрушечном примере это можно представить следующим образом:



2. Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения, указанное после оператора ON.

3. После этого в соответствии с выбранным типом объединения формируется результирующая таблица. 

При соединении не двух, а нескольких таблиц, операция соединения выполняется последовательно несколько раз, т.е. описанный выше алгоритм запускается столько раз, сколько указано соединений. При этом в этой последовательности при каждом объединении может использоваться любой тип соединения (INNER, LEFT и т.д.).

Для двух соединений запрос может выглядеть примерно следующим образом:

SELECT a.column_1, b.column_2
FROM table_1 a 
     LEFT JOIN table_2 b
     ON a.user_id = b.user_id
     JOIN table_3 c
     ON b.order_id = c.order_id
...


О том, как именно выбор типа JOIN влияет на результат, мы и будем говорить в этом уроке.

Если что-то на этом шаге осталось непонятным, не переживайте. Сейчас всё проясним на практических примерах!
Задача 1. INNER JOIN
Первый тип объединения, который мы рассмотрим, называется INNER JOIN. Это оператор внутреннего соединения, для которого совершенно неважен порядок указания таблиц, т.е. в следующих случаях результат объединения будет одинаковым:

SELECT ...
FROM table_1 INNER JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 INNER JOIN table_1 
     ON [condition]
...


При этом в запросе вместо INNER JOIN можно писать просто JOIN — это одно и то же.

Результат объединения INNER JOIN формируется следующим образом:

Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Таким образом, в результате объединения INNER JOIN из двух таблиц отбрасываются все строки, которые не прошли проверку на соответствие указанному условию. Вот и всё!

Рассмотрим следующий игрушечный пример:

SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     JOIN table_B as B
     ON A.id = B.id


В результате такого запроса таблицы table_A и table_B будут объединены в таблицу table_С:


Поскольку таблицы совпадают только по одному значению в столбце id, то в результат будет включена только одна запись.

Схематично результат работы объединений принято изображать в виде диаграмм Венна. Для INNER JOIN диаграмма выглядит так:


Задача 3. LEFT JOIN
Следующий тип соединения, который мы рассмотрим, — это LEFT OUTER JOIN (или просто LEFT JOIN). 

LEFT JOIN — это оператор внешнего соединения, для которого важен порядок таблиц в запросе, т.е. в отличие от INNER JOIN он не является симметричным.

Поэтому следующие две записи уже не являются эквивалентными:

SELECT ...
FROM table_1 LEFT JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 LEFT JOIN table_1 
     ON [condition]
...


Результат объединения LEFT JOIN формируется следующим образом:

Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Далее в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
Если внимательно посмотреть на описанный алгоритм, то можно понять, что он легко сводится к следующей последовательности действий:

Сначала в соответствии с указанным условием выполняется INNER JOIN первой и второй таблиц.
Затем в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
Вот и вся магия!

Соединение RIGHT JOIN работает аналогичным образом, только на втором этапе в результат INNER JOIN добавляются записи не из левой, а из правой таблицы.

Давайте снова рассмотрим пару простых примеров.

Так будет выглядеть запрос и его результат с LEFT JOIN:

SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     LEFT JOIN table_B as B
     ON A.id = B.id



В данном случае в результат попадёт запись с id 2, так как она есть в обеих таблицах, а также запись с id 1 из левой таблицы.

Диаграмма Венна для LEFT JOIN выглядит так:


А вот таким получится результат запроса с RIGHT JOIN:

SELECT B.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     RIGHT JOIN table_B as B
     ON A.id = B.id



Всё как и в случае с LEFT JOIN, только в результат уже попадёт недостающая запись с id 3 из правой таблицы.

Диаграмма Венна для RIGHT JOIN:


Задача 6. FULL JOIN
А чтобы лучше разобраться с джойнами, рассмотрим ещё один тип объединения таблиц — FULL OUTER JOIN или просто FULL JOIN. Это оператор полного внешнего соединения, для которого, как и для INNER JOIN, неважен порядок указания таблиц. Однако работает он совсем по-другому.

Запрос с FULL OUTER JOIN выглядит примерно так:

SELECT ...
FROM table_1 FULL JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 FULL JOIN table_1 
     ON [condition]
...


Результат объединения FULL JOIN формируется следующим образом:

Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из другой таблицы (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями NULL.
Этот алгоритм можно свести к следующей последовательности действий:

Сначала в соответствии с указанным условием выполняется INNER JOIN левой и правой таблиц.
Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из другой таблицы (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями NULL.
Рассмотрим простой пример.

Так будет выглядеть запрос и его результат с FULL JOIN:

SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     FULL JOIN table_B as B
     ON A.id = B.id



В результат попала общая запись с id 2, а также все недостающие записи из других таблиц. Все несоответствия были заполнены пустыми значениями.

Диаграмма Венна для FULL JOIN:


На заметку:

Подробнее про FULL JOIN можно почитать здесь.

А теперь давайте разберёмся с FULL JOIN на примере нашей базы данных.

У нас есть две таблицы с датами рождения пользователей и курьеров — users и couriers. Можно предположить, что в каждой таблице в колонке birth_date есть какие-то даты, которых нет в другой таблице. То есть есть такие даты, в которые родился кто-то из курьеров, но не родился ни один пользователь, и наоборот. Ну что ж, давайте попробуем проверить эту гипотезу.

Для начала сгруппируем две таблицы по колонке birth_date и посчитаем, сколько пользователей/курьеров родились в каждый из дней. Для этого можете выполнить в Redash следующие запросы: 

SELECT birth_date, COUNT(user_id) AS users_count
FROM users
WHERE birth_date IS NOT NULL
GROUP BY birth_date


SELECT birth_date, COUNT(courier_id) AS couriers_count
FROM couriers
WHERE birth_date IS NOT NULL
GROUP BY birth_date


В результате у вас получатся две таблицы с уникальными датами и количеством людей, родившихся в каждый из дней. Давайте их объединим.


