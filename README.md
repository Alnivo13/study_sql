# study_sql
БАЗОВЫЕ ЗАПРОСЫ SQL
1.Выведите все записи из таблицы products.

Поля в результирующей таблице: product_id, name, price
SELECT product_id,
       name,
       price
FROM   products
2.Выведите все записи из таблицы products, отсортировав их по наименованиям товаров в алфавитном порядке, т.е. по возрастанию. Для сортировки используйте оператор ORDER BY.

Поля в результирующей таблице: product_id, name, price
SELECT product_id,
       name,
       price
FROM   products
ORDER BY name
3. Отсортируйте таблицу courier_actions сначала по колонке courier_id по возрастанию id курьера, потом по колонке action (снова по возрастанию), а затем по колонке time, но уже по убыванию — от самого последнего действия к самому первому. Не забудьте включить в результат колонку order_id.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: courier_id, order_id, action, time

Пояснение:

Как вы уже догадались, сортировать таблицы можно в том числе по полям с датами и временем.

ELECT courier_id,
       order_id,
       action,
       time
FROM   courier_actions
ORDER BY courier_id, action, time desc limit 100
4. Используя операторы SELECT, FROM, ORDER BY и LIMIT, определите 5 самых дорогих товаров в таблице products, которые доставляет наш сервис. Выведите их наименования и цену.

Поля в результирующей таблице: name, price
SELECT name,
       price
FROM   products
ORDER BY price desc limit 5

5.Как в прошлом задании определите 5 самых дорогих товаров в таблице products. Но теперь колонки name и price переименуйте соответственно в product_name и product_price.

Поля в результирующей таблице: product_name, product_price
SELECT name as product_name,
       price as product_price
FROM   products
ORDER BY price desc limit 5

6.Используя операторы SELECT, FROM, ORDER BY и LIMIT, а также функцию LENGTH, определите товар с самым длинным названием в таблице products. Выведите его наименование, длину наименования в символах, а также цену этого товара. Колонку с длиной наименования в символах назовите name_length.

Поля в результирующей таблице: name, name_length, price
Пояснение:

Обратите внимание, что в этой задаче вам придётся сортировать результирующую таблицу по расчётной колонке name_length, которой изначально не было в таблице products.

Такая сортировка по новым колонкам возможна, поскольку это согласуется с порядком выполнения операторов в запросе: сначала выполняется выбор колонок и все преобразования над ними в операторе SELECT — и только потом производится сортировка по указанным в ORDER BY столбцам. То есть к моменту сортировки все расчётные поля уже существуют, а значит, их можно указывать в ORDER BY.

Также обратите внимание, что мы дважды указываем колонку name в операторе SELECT: в первый раз просто обращаемся к ней по имени, а во второй — используем её в качестве аргумента функции LENGTH. В этом случае тоже нет никаких противоречий — мы можем выбирать колонку столько раз, сколько необходимо, причём для этого даже необязательно присваивать этим колонкам разные алиасы (база данных сама переименует дубликат колонки).

SELECT name,
       length(name) as name_length,
       price
FROM   products
ORDER BY name_length desc limit 1
7. Задание:

Примените последовательно функции UPPER и SPLIT_PART к колонке name и преобразуйте наименования товаров в таблице products так, чтобы от названий осталось только первое слово, записанное в верхнем регистре. Колонку с новым названием, состоящим из первого слова, назовите first_word.

В результат включите исходные наименования товаров, новые наименования из первого слова, а также цену товаров. Результат отсортируйте по возрастанию исходного наименования товара в колонке name.

Поля в результирующей таблице: name, first_word, price

SELECT name,
       upper(split_part(name, ' ', 1)) as first_word,
       price
FROM   products
ORDER BY name

8. Задание:

Измените тип колонки price из таблицы products на VARCHAR. Выведите колонки с наименованием товаров, ценой в исходном формате и ценой в формате VARCHAR. Новую колонку с ценой в новом формате назовите price_char.

Результат отсортируйте по возрастанию наименования товара в колонке name. Количество выводимых записей не ограничивайте.

Поле в результирующей таблице: name, price, price_char

SELECT name,
       price,
       cast(price as varchar) as price_char
FROM   products
ORDER BY name

9. Задание:

Для первых 200 записей из таблицы orders выведите информацию в следующем виде (обратите внимание на пробелы):

Заказ № [id заказа] создан [дата]

Полученную колонку назовите order_info.

Пример вывода:

Заказ № 65 создан 2022-09-01


Пояснение:

При указании текстовых значений используйте одинарные кавычки. Пробелы вносите вместе со словами, а не отдельными текстовыми значениями.

Чтобы извлечь дату из значений в колонке creation_time, достаточно применить к ней функцию DATE или изменить её тип на DATE:

SELECT DATE(time)

SELECT CAST(time AS DATE)

SELECT time::DATE

SELECT concat('Заказ №',
              ' ',
              order_id ,
              ' создан ',
              cast(creation_time as date)) as order_info
FROM   orders
ORDER BY order_id limit 200
10. Задание:

Выведите id всех курьеров и их годы рождения из таблицы couriers.

Год рождения необходимо получить из колонки birth_date. Новую колонку с годом назовите birth_year. Результат отсортируйте сначала по убыванию года рождения курьера (т.е. от самых младших к самым старшим), затем по возрастанию id курьера.

Поля в результирующей таблице: courier_id, birth_year
SELECT courier_id,
       date_part('year', birth_date) as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id
11.Задание:

Как и в предыдущем задании, снова выведите id всех курьеров и их годы рождения, только теперь к извлеченному году примените функцию COALESCE. Укажите параметры функции так, чтобы вместо NULL значений в результат попадало текстовое значение unknown. Названия полей оставьте прежними.

Отсортируйте итоговую таблицу сначала по убыванию года рождения курьера, затем по возрастанию id курьера.

Поля в результирующей таблице: courier_id, birth_year

Пояснение:

При указании текстового значения используйте одинарные кавычки, как в примерах выше.

Не забудьте учесть, что unknown — значение типа VARCHAR, а значит, извлечённый из даты год нужно тоже привести к этому типу. Поэтому сначала извлеките год, затем преобразуйте его в текст и далее применяйте к полученному значению функцию COALESCE.
SELECT courier_id,
       coalesce(date_part('year', birth_date)::varchar, 'unknown') as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id

12. Задание:

Давайте представим, что по какой-то необъяснимой причине мы вдруг решили в одночасье повысить цену всех товаров в таблице products на 5%.

Выведите id и наименования всех товаров, их старую и новую цену. Колонку со старой ценой назовите old_price, а колонку с новой — new_price.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price
SELECT product_id,
       name,
       price as old_price,
       price*1.05 as new_price
FROM   products
ORDER BY new_price desc, product_id
13.Задание:

Вновь, как и в прошлом задании, повысьте цену всех товаров на 5%, только теперь к колонке с новой ценой примените функцию ROUND. Выведите id и наименования товаров, их старую цену, а также новую цену с округлением. Новую цену округлите до одного знака после запятой, но тип данных не меняйте.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price
SELECT product_id,
       name,
       price as old_price,
       round(price*1.05, 1) as new_price
FROM   products
ORDER BY new_price desc, product_id

14. задание:

Повысьте цену на 5% только на те товары, цена которых превышает 100 рублей. Цену остальных товаров оставьте без изменений. Также не повышайте цену на икру, которая и так стоит 800 рублей. Выведите id и наименования всех товаров, их старую и новую цену. Цену округлять не нужно.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price
SELECT product_id,
       name,
       price as old_price,
       case when price <= 100 or
                 name = 'икра' then price
            when price > 100 then price*1.05
            else 0 end new_price
FROM   products
ORDER BY new_price desc, product_id
15. Задание:

Вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно tax и price_before_tax. Округлите значения в этих колонках до двух знаков после запятой.

Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, tax, price_before_tax

Пояснение:

Так как НДС уже включён в текущую цену, налог считаем следующим образом: делим цену на 120% и умножаем на 20%.

Почему налог считается именно так, можно прочитать здесь.
SELECT product_id,
       name,
       price,
       round((price/120)*20, 2) as tax,
       round (price - ((price/120)*20), 2) as price_before_tax
FROM   products
ORDER BY price_before_tax desc, product_id


ФИЛЬТРАЦИЯ данных

1.Задание:

Напишите SQL-запрос к таблице products и выведите всю информацию о товарах, цена которых не превышает 100 рублей. Результат отсортируйте по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price

SELECT product_id,
       name,
       price
FROM   products
WHERE  price <= 100
ORDER BY product_id limit 100

2. Задание:

Отберите пользователей женского пола (female) из таблицы users. Выведите только id этих пользователей. Результат отсортируйте по возрастанию id.

Добавьте в запрос оператор LIMIT и выведите только 1000 первых id из отсортированного списка.

Поле в результирующей таблице: user_id

Пояснение:

Обратите внимание, что в SELECT можно не включать колонку, которая используется для фильтрации в операторе WHERE. Так, например, в этом задании мы не включаем в результат колонку с полом пользователя.
SELECT user_id
FROM   users
WHERE  sex = 'female'
ORDER BY user_id limit 1000

3. Задание:

Отберите из таблицы user_actions все действия пользователей по созданию заказов, которые были совершены ими после полуночи 6 сентября 2022 года. Выведите колонки с id пользователей, id созданных заказов и временем их создания.

Результат должен быть отсортирован по возрастанию id заказа.

Поля в результирующей таблице: user_id, order_id, time

Пояснение:

Обратите внимание, что в таблице user_actions у каждого пользователя могут быть записи не только со временем создания заказа, но и временем его отмены. Нам необходимо получить только записи с созданием заказов.

SELECT user_id,
       order_id,
       time
FROM   user_actions
WHERE  time >= '2022-09-06'
   and action = 'create_order'
ORDER BY order_id

4.Задание:

Назначьте скидку 20% на все товары из таблицы products и отберите те, цена на которые с учётом скидки превышает 100 рублей. Выведите id товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите old_price, с новой — new_price.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price

Пояснение:

Будьте внимательны, когда будете указывать фильтр после оператора WHERE.
ELECT product_id,
       name,
       price as old_price,
       price - price * 0.2 as new_price
FROM   products
WHERE  price-price * 0.2 > 100
ORDER BY product_id
5. Задание:

Отберите из таблицы products все товары, названия которых либо начинаются со слова «чай», либо состоят из пяти символов. Выведите две колонки: id товаров и их наименования.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name

Пояснение:

Для решения задачи вам пригодятся функции SPLIT_PART и LENGTH, которые мы рассматривали на прошлом уроке.

SELECT product_id,
       name
FROM   products
WHERE  split_part(name, ' ', 1) = 'чай'
    or length(name) = 5
ORDER BY product_id
6. Задание:

Отберите из таблицы products все товары, содержащие в своём названии последовательность символов «чай» (без кавычек). Выведите две колонки: id продукта и его название.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name

SELECT product_id,
       name
FROM   products
WHERE  name like '%чай%'
ORDER BY product_id

7. Задание:

Выберите из таблицы products id и наименования только тех товаров, названия которых начинаются на букву «с» и содержат только одно слово.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name
SELECT product_id,
       name
FROM   products
WHERE  name like 'с%'
   and name not like '% %'
ORDER BY product_id
8.Задание:

Составьте SQL-запрос, который выбирает из таблицы products все чаи стоимостью больше 60 рублей и вычисляет для них цену со скидкой 25%.

Скидку в % менеджер попросил указать в отдельном столбце в формате текста, то есть вот так: «25%» (без кавычек). Столбцы со скидкой и новой ценой назовите соответственно discount и new_price.

Также необходимо любым известным способом избавиться от «чайного гриба»: вряд ли менеджер имел в виду и его, когда ставил нам задачу.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, discount, new_price

Пояснение:

Чтобы указать столбец с одним значением для всех записей (в нашем случае это столбец со скидкой), достаточно просто ввести нужное значение и дать столбцу какое-то название — указанное значение автоматически проставится во всех строках результирующей таблицы:

SELECT column_1, 'text' AS column_2
FROM table
SELECT product_id,
       name,
       price,
       '25%' as discount,
       price - price*0.25 as new_price
FROM   products
WHERE  price > 60
   and name like 'чай%'
   and name not like '%гриб%'
ORDER BY product_id
9. Задание:

Из таблицы user_actions выведите всю информацию о действиях пользователей с id 170, 200 и 230 за период с 25 августа по 4 сентября 2022 года включительно. Результат отсортируйте по убыванию id заказа — то есть от самых поздних действий к самым первым.

Поля в результирующей таблице: user_id, order_id, action, time
SELECT user_id,
       order_id,
       action,
       time
FROM   user_actions
WHERE  user_id in (170, 200, 230)
   and time between '2022-08-25 00:00:00'
   and '2022-09-04 23:59:59'
ORDER BY order_id desc
10. Задание:

Напишите SQL-запрос к таблице couriers и выведите всю информацию о курьерах, у которых не указан их день рождения.

Результат должен быть отсортирован по возрастанию id курьера.

Поля в результирующей таблице: birth_date, courier_id, sex
SELECT birth_date,
       courier_id,
       sex
FROM   couriers
WHERE  birth_date is null
ORDER BY courier_id

11. Задание:

Определите id и даты рождения 50 самых молодых пользователей мужского пола из таблицы users. Не учитывайте тех пользователей, у которых не указана дата рождения.

Поле в результирующей таблице: user_id, birth_date
SELECT user_id,
       birth_date
FROM   users
WHERE  birth_date is not null
   and sex = 'male'
ORDER BY birth_date desc limit 50
12. Задание:

Напишите SQL-запрос к таблице courier_actions, чтобы узнать id и время доставки последних 10 заказов, доставленных курьером с id 100.

Поля в результирующей таблице: order_id, time

Пояснение:

Обратите внимание, что в исходной таблице есть записи не только со временем доставки, но и временем принятия заказа.
SELECT order_id,
       time
FROM   courier_actions
WHERE  courier_id = '100'
   and action = 'deliver_order'
ORDER BY time desc limit 10
13. Задание:

Из таблицы user_actions получите id всех заказов, сделанных пользователями сервиса в августе 2022 года.

Результат отсортируйте по возрастанию id заказа.

Поле в результирующей таблице: order_id

Пояснение:

Обратите внимание, что в исходной таблице есть записи не только со временем оформления, но и временем отмены заказа.

В этой задаче вам может пригодиться функция DATE_PART. Мы рассматривали её на прошлом уроке в этом задании.
SELECT order_id
FROM   user_actions
WHERE  date_part ('month', time) = '08'
   and date_part ('year', time) = 2022
   and action = 'create_order'
ORDER BY order_id
14. Задание:

Из таблицы couriers отберите id всех курьеров, родившихся в период с 1990 по 1995 год включительно.

Результат отсортируйте по возрастанию id курьера.

Поле в результирующей таблице: courier_id

Пояснение:

В этой задаче вам снова может пригодиться функция DATE_PART.

SELECT courier_id
FROM   couriers
WHERE  birth_date is not null
   and date_part('year', birth_date) between 1990
   and 1995
ORDER BY courier_id

15. Задание:

Из таблицы user_actions получите информацию о всех отменах заказов, которые пользователи совершали в течение августа 2022 года по средам с 12:00 до 15:59:59.

Результат отсортируйте по убыванию id отменённых заказов.

Поля в результирующей таблице: user_id, order_id, action, time

Пояснение:

Будьте внимательны при работе с датами и временем.

Для решения задачи вам может пригодиться функция DATE_PART. Для получения дня недели можно указать аргумент 'dow' («day of week»):

SELECT DATE_PART('dow', DATE '2022-12-31')

Результат:
6.00


В PostgreSQL дни недели считаются с воскресенья (0) до субботы (6).
SELECT user_id,
       order_id,
       action,
       time
FROM   user_actions
WHERE  action = 'cancel_order'
   and date_part('year', time) = 2022
   and date_part('month', time) = 08
   and date_part('dow', time) = 3
   and date_part('hour', time) between 12
   and 15
ORDER BY order_id desc
16. Задание:

Как и в задаче из прошлого урока, вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Однако теперь примите во внимание, что для товаров из списка налог составляет 10%. Для остальных товаров НДС тот же — 20%.

Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно tax и price_before_tax. Округлите значения в этих колонках до двух знаков после запятой.

Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, tax, price_before_tax

Пояснение:

Порядок расчёта налога тот же, что и в задании из прошлого урока.

Для решения задачи вам могут пригодиться конструкция CASE и оператор IN. Конструкцию CASE мы рассматривали в этом задании.

SELECT product_id,
       name,
       price,
       case when name in ('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') then round((price/110)*10,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         2)
            else round((price/120)*20, 2) end as tax,
       case when name in ('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград',
                          'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки',
                          'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины',
                          'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука',
                          'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное',
                          'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая',
                          'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко',
                          'курица', 'лаваш', 'вафли', 'мандарины') then round (price - ((price/110)*10), 2)
            else round (price - ((price/120)*20), 2) end as price_before_tax
FROM   products
ORDER BY price_before_tax desc, product_id


АГРЕГАЦИЯ ДАННЫХ 
1. Задание:

Выведите id всех уникальных пользователей из таблицы user_actions. Результат отсортируйте по возрастанию id.

Поле в результирующей таблице: user_id
SELECT DISTINCT user_id
FROM   user_actions
ORDER BY user_id

2. Задание:

Примените DISTINCT сразу к двум колонкам таблицы courier_actions и отберите уникальные пары значений courier_id и order_id.

Результат отсортируйте сначала по возрастанию id курьера, затем по возрастанию id заказа.

Поля в результирующей таблице: courier_id, order_id

SELECT DISTINCT courier_id,
                order_id
FROM   courier_actions
ORDER BY courier_id, order_id

3. Задание:

Посчитайте максимальную и минимальную цены товаров в таблице products. Поля назовите соответственно max_price, min_price.

Поля в результирующей таблице: max_price, min_price

Пояснение:

В одном запросе можно использовать сразу несколько агрегирующих функций — если необходимо, то даже по нескольким разным колонкам.
SELECT max(price) as max_price,
       min(price) as min_price
FROM   products
4. Задание:

Как вы помните, в таблице users у некоторых пользователей не были указаны их даты рождения.

Посчитайте в одном запросе количество всех записей в таблице и количество только тех записей, для которых в колонке birth_date указана дата рождения.

Колонку с общим числом записей назовите dates, а колонку с записями без пропусков — dates_not_null.

Поля в результирующей таблице: dates, dates_not_null
SELECT count (*) as dates,
       count (birth_date) as dates_not_null
FROM   users

5.Задача:

Посчитайте количество всех значений в колонке user_id в таблице user_actions, а также количество уникальных значений в этой колонке (т.е. количество уникальных пользователей сервиса).

Колонку с первым полученным значением назовите users, а колонку со вторым — unique_users.

Поля в результирующей таблице: users, unique_users
SELECT count (user_id) as users,
       count(distinct user_id) as unique_users
FROM   user_actions

6. Задание:

Посчитайте количество курьеров женского пола в таблице couriers. Полученный столбец с одним значением назовите couriers.

Поле в результирующей таблице: couriers
SELECT count(sex) as couriers
FROM   couriers
WHERE  sex = 'female'

7. Задача:

Рассчитайте время, когда были совершены первая и последняя доставки заказов в таблице courier_actions.

Колонку с временем первой доставки назовите first_delivery, а колонку с временем последней — last_delivery.

Поля в результирующей таблице: first_delivery, last_delivery
SELECT min(time) as first_delivery,
       max(time) as last_delivery
FROM   courier_actions
WHERE  action = 'deliver_order'

8. Задание:

Представьте, что один из пользователей сервиса сделал заказ, в который вошли одна пачка сухариков, одна пачка чипсов и один энергетический напиток. Посчитайте стоимость такого заказа.

Колонку с рассчитанной стоимостью заказа назовите order_price.

Для расчётов используйте таблицу products.

Поле в результирующей таблице: order_price
SELECT sum(price) as order_price
FROM   products
WHERE  name in ('чипсы','энергетический напиток','сухарики')

9. Задание:

Посчитайте количество заказов в таблице orders с девятью и более товарами. Для этого воспользуйтесь функцией array_length, отфильтруйте данные по количеству товаров в заказе и проведите агрегацию. Полученный столбец назовите orders.

Поле в результирующей таблице: orders

Пояснение:

В наших данных в колонке product_ids содержатся обычные списки товаров всего с одной размерностью.

SELECT count(order_id) as orders
FROM   orders
WHERE  array_length(product_ids, 1) >= 9

10.Задание:

С помощью функции AGE и агрегирующей функции рассчитайте возраст самого молодого курьера мужского пола в таблице couriers.

Возраст выразите количеством лет, месяцев и дней (как в примере выше), переведя его в тип VARCHAR. 

В качестве даты, относительно которой считать возраст курьеров, используйте свою текущую дату (либо не указывайте её на месте первого аргумента, как показано в примерах).

Полученную колонку со значением возраста назовите min_age.

Поле в результирующей таблице: min_age

SELECT min(age(current_date, birth_date))::varchar as min_age
FROM   couriers
WHERE  sex = 'male'

Задание:

Посчитайте стоимость заказа, в котором будут три пачки сухариков, две пачки чипсов и один энергетический напиток. Колонку с рассчитанной стоимостью заказа назовите order_price.

Для расчётов используйте таблицу products.

Поле в результирующей таблице: order_price
SELECT sum(case when name = 'сухарики' then price * 3
                when name = 'чипсы' then price * 2
                when name = 'энергетический напиток' then price * 1
                when name not in ('сухарики','чипсы','энергетический напиток') then price * 0
                else price end) as order_price
FROM   products

12. Задание:

Рассчитайте среднюю цену товаров в таблице products, в названиях которых присутствуют слова «чай» или «кофе». Любым известным способом исключите из расчёта товары, содержащие в названии «иван-чай» или «чайный гриб».

Среднюю цену округлите до двух знаков после запятой. Столбец с полученным значением назовите avg_price.

Поле в результирующей таблице: avg_price

SELECT round(avg(price), 2) as avg_price
FROM   products
WHERE  name like 'чай %'
    or name like '%кофе%'

13.Задание:

Воспользуйтесь функцией AGE и рассчитайте разницу в возрасте между самым старым и самым молодым пользователями мужского пола в таблице users. 

Разницу в возрасте выразите количеством лет, месяцев и дней, переведя её в тип VARCHAR. 

Колонку с посчитанным значением назовите age_diff.

Поле в результирующей таблице: age_diff

SELECT age(max(birth_date), min(birth_date))::varchar as age_diff
FROM   users
WHERE  sex = 'male'

14. Задание:

Рассчитайте среднее количество товаров в заказах из таблицы orders, которые пользователи оформляли по выходным дням (суббота и воскресенье) в течение всего времени работы сервиса.

Полученное значение округлите до двух знаков после запятой. Колонку с ним назовите avg_order_size.

Поле в результирующей таблице: avg_order_size
SELECT round(avg(array_length(product_ids, 1)), 2) as avg_order_size
FROM   orders
WHERE  date_part('dow', creation_time) in (0, 6)

15.Задание:

На основе данных в таблице user_actions посчитайте количество уникальных пользователей сервиса, количество уникальных заказов, поделите одно на другое и выясните, сколько заказов приходится на одного пользователя.

В результирующей таблице отразите все три значения — поля назовите соответственно unique_users, unique_orders, orders_per_user.

Показатель числа заказов на пользователя округлите до двух знаков после запятой.

Поля в результирующей таблице: unique_users, unique_orders, orders_per_user
SELECT count(distinct(user_id)) as unique_users,
       count(distinct(order_id)) as unique_orders,
       round((count(distinct(order_id)))/(count(distinct(user_id)))::decimal,
             2) as orders_per_user
FROM   user_actions
16. Задание:

Посчитайте, сколько пользователей никогда не отменяли свой заказ. Для этого из общего числа всех уникальных пользователей отнимите число уникальных пользователей, которые хотя бы раз отменяли заказ. Подумайте, какое условие необходимо указать в FILTER, чтобы получить корректный результат.

Полученный столбец назовите users_count.

Поле в результирующей таблице: users_count
SELECT (count(distinct(user_id))) - (count(distinct(user_id)) filter (WHERE action != 'create_order')) as users_count
FROM   user_actions
17. Задание:

Посчитайте общее количество заказов в таблице orders, количество заказов с пятью и более товарами и найдите долю заказов с пятью и более товарами в общем количестве заказов.

В результирующей таблице отразите все три значения — поля назовите соответственно orders, large_orders, large_orders_share.

Долю заказов с пятью и более товарами в общем количестве товаров округлите до двух знаков после запятой.

Поля в результирующей таблице: orders, large_orders, large_orders_share
SELECT count(order_id) as orders,
       count(order_id) filter (WHERE array_length(product_ids, 1) >= 5) as large_orders,
       round((count(order_id) filter (WHERE array_length(product_ids, 1) >= 5)::decimal)/ (count(order_id)),
             2) as large_orders_share
FROM   orders
ГРУППИРОВКА ДАННЫХ

1. Задание:

С помощью оператора GROUP BY посчитайте количество курьеров мужского и женского пола в таблице couriers.

Новую колонку с числом курьеров назовите couriers_count.

Результат отсортируйте по этой колонке по возрастанию.

Поля в результирующей таблице: sex, couriers_count
SELECT sex,
       count(courier_id) as couriers_count
FROM   couriers
GROUP BY sex
ORDER BY couriers_count

2.Задание:

Посчитайте количество созданных и отменённых заказов в таблице user_actions.

Новую колонку с числом заказов назовите orders_count.

Результат отсортируйте по числу заказов по возрастанию.

Поля в результирующей таблице: action, orders_count
SELECT action,
       count(order_id) as orders_count
FROM   user_actions
GROUP BY action

3. Задание:

Используя группировку и функцию DATE_TRUNC, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано в каждом из них.

Расчёты проведите по таблице orders. Колонку с усечённой датой назовите month, колонку с количеством заказов — orders_count.

Результат отсортируйте по месяцам — по возрастанию.

Поля в результирующей таблице: month, orders_count

SELECT date_trunc('month', creation_time) as month,
       count(order_id) as orders_count
FROM   orders
GROUP BY date_trunc('month', creation_time)
ORDER BY month asc

4. Задание:

Используя группировку и функцию DATE_TRUNC, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано и сколько было отменено в каждом из них.

В этот раз расчёты проведите по таблице user_actions. Колонку с усечённой датой назовите month, колонку с количеством заказов — orders_count.

Результат отсортируйте сначала по месяцам — по возрастанию, затем по типу действия — тоже по возрастанию.

Поля в результирующей таблице: month, action, orders_count

Пояснение:

В результате группировки по двум полям для каждого месяца у вас должно появиться ещё по две подгруппы с типом действия (создание заказа и отмена). В каждой такой подгруппе необходимо посчитать число заказов.
SELECT date_trunc('month', time) as month,
       action,
       count (order_id) as orders_count
FROM   user_actions
GROUP BY month, action
SELECT max(date_part('month', birth_date))::integer as max_month,
       sex
FROM   users
GROUP BY sex

5. По данным в таблице users посчитайте максимальный порядковый номер месяца среди всех порядковых номеров месяцев рождения пользователей сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку с максимальным порядковым номером месяца рождения в группах назовите max_month. Преобразуйте значения в новой колонке в формат INTEGER, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей.

Поля в результирующей таблице: sex, max_month

SELECT max(date_part('month', birth_date))::integer as max_month,
       sex
FROM   users
GROUP BY sex


6. Задание:

По данным в таблице users посчитайте порядковый номер месяца рождения самого молодого пользователя сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку c порядковым номером месяца рождения самого молодого пользователя в группах назовите max_month. Преобразуйте значения в новой колонке в формат INTEGER, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей.

Поля в результирующей таблице: sex, max_month
SELECT sex,
       date_part('month', max(birth_date))::integer as max_month
FROM   users
GROUP BY sex





7. Задание:

Посчитайте максимальный возраст пользователей мужского и женского пола в таблице users. Возраст измерьте числом полных лет.

Новую колонку с возрастом назовите max_age. Преобразуйте значения в новой колонке в формат INTEGER, чтобы возраст был выражен целым числом.

Результат отсортируйте по новой колонке по возрастанию возраста.

Поля в результирующей таблице: sex, max_age

Пояснение:

Для вычисления количества полных лет используйте функцию AGE.

В качестве даты, относительно которой считать возраст пользователей, используйте свою текущую дату.

Чтобы извлечь число полных лет из возраста, можно использовать функцию DATE_PART с аргументом 'year'.

Вспомнить, как работает функция AGE, можно на этом шаге.

Время не стоит на месте, поэтому верный ответ может отличаться от примера в ожидаемом результате. Используйте его как ориентир формата ответа.

SELECT sex,
       date_part('year', max(age(current_date, birth_date)))::varchar as max_age
FROM   users
GROUP BY sex

8. Задание:

Разбейте пользователей из таблицы users на группы по возрасту (возраст по-прежнему измеряем числом полных лет) и посчитайте количество пользователей каждого возраста.

Колонку с возрастом назовите age, а колонку с числом пользователей — users_count. Преобразуйте значения в колонке с возрастом в формат INTEGER, чтобы возраст был выражен целым числом.

Результат отсортируйте по колонке с возрастом по возрастанию.

Поля в результирующей таблице: age, users_count

Пояснение:

Число полных лет из возраста рассчитывайте тем же способом, что и в предыдущем задании.

Обратите внимание, что у части пользователей вместо возраста будет пропуск. Эту группу также включите в результат и посчитайте число пользователей в ней.

В данной задаче вам необходимо провести группировку по новому расчётному полю. Помните, что повторно производить вычисления в GROUP BY не обязательно, достаточно взять алиас колонки из SELECT.

Время не стоит на месте, поэтому верный ответ может отличаться от примера в ожидаемом результате. Используйте его как ориентир формата ответа.

SELECT count(user_id) as users_count,
       date_part('year', age(current_date, birth_date))::integer as age
FROM   users
GROUP BY age
ORDER BY age

9.Задание:

Вновь разбейте пользователей из таблицы users на группы по возрасту (возраст по-прежнему измеряем количеством полных лет), только теперь добавьте в группировку ещё и пол пользователя. Затем посчитайте количество пользователей в каждой половозрастной группе.

Все NULL значения в колонке birth_date заранее отфильтруйте с помощью WHERE.

Колонку с возрастом назовите age, а колонку с числом пользователей — users_count, имя колонки с полом оставьте без изменений. Преобразуйте значения в колонке с возрастом в формат INTEGER, чтобы возраст был выражен целым числом.

Отсортируйте полученную таблицу сначала по колонке с возрастом по возрастанию, затем по колонке с полом — тоже по возрастанию.

Поля в результирующей таблице: age, sex, users_count

Пояснение:

В результате в каждой возрастной группе должно появиться ещё по две подгруппы с полом. В каждой такой подгруппе необходимо посчитать число пользователей.

Число полных лет из возраста рассчитывайте тем же способом, что и в предыдущих заданиях.

Будьте внимательны: оператор WHERE всегда указывается перед оператором GROUP BY. Если указать его после, то база данных вернёт ошибку.

Вспомнить, как отфильтровываются NULL значения, можно здесь.

Время не стоит на месте, поэтому верный ответ может отличаться от примера в ожидаемом результате. Используйте его как ориентир формата ответа.
SELECT date_part('year', age(birth_date))::integer as age,
       sex,
       count(user_id) as users_count
FROM   users
WHERE  birth_date is not null
GROUP BY age, sex
ORDER BY age, sex
10. Задание:

Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе за неделю с 29 августа по 4 сентября 2022 года включительно. Для расчётов используйте данные из таблицы orders.

Выведите две колонки: размер заказа и число заказов такого размера за указанный период. Колонки назовите соответственно order_size и orders_count.

Результат отсортируйте по возрастанию размера заказа.

Поля в результирующей таблице: order_size, orders_count
SELECT array_length(product_ids, 1) as order_size,
       count(order_id) as orders_count
FROM   orders
WHERE  creation_time between'2022-08-29'
   and '2022-09-04 23:59:59'
GROUP BY order_size
ORDER BY order_size

11.Задание:

Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе. Учитывайте только заказы, оформленные по будням. В результат включите только те размеры заказов, общее число которых превышает 2000. Для расчётов используйте данные из таблицы orders.

Выведите две колонки: размер заказа и число заказов такого размера. Колонки назовите соответственно order_size и orders_count.

Результат отсортируйте по возрастанию размера заказа.

Поля в результирующей таблице: order_size, orders_count

Когда решите эту задачу, вернитесь к одной из предыдущих и подумайте, могли бы мы ещё каким-то способом сделать так, чтобы в результат не попала группа с NULL значениями. Можете самостоятельно написать ещё один запрос и попробовать сдать его в качестве альтернативного решения.

SELECT array_length(product_ids, 1) as order_size,
       count(order_id) as orders_count
FROM   orders
WHERE  to_char(creation_time, 'Dy') in ('Mon', 'Tue', 'Wed', 'Thu', 'Fri')
GROUP BY order_size having count(order_id) > 2000
ORDER BY order_size
12. Задание:

По данным из таблицы user_actions определите пять пользователей, сделавших в августе 2022 года наибольшее количество заказов.

Выведите две колонки — id пользователей и число оформленных ими заказов. Колонку с числом оформленных заказов назовите created_orders.

Результат отсортируйте сначала по убыванию числа заказов, сделанных пятью пользователями, затем по возрастанию id этих пользователей.

Поля в результирующей таблице: user_id, created_orders

Пояснение:

Помните, что в таблице user_actions есть информация как об оформленных, так и об отменённых заказах.

SELECT user_id,
       count(action) as created_orders
FROM   user_actions
WHERE  date_part('month', time)::integer = 8
   and action = 'create_order'
GROUP BY user_id
ORDER BY created_orders desc, user_id limit 5
13. Задание:

А теперь по данным таблицы courier_actions определите курьеров, которые в сентябре 2022 года доставили только по одному заказу.

В этот раз выведите всего одну колонку с id курьеров. Колонку с числом заказов в результат включать не нужно.

Результат отсортируйте по возрастанию id курьера.

Поле в результирующей таблице: courier_id

SELECT courier_id
FROM   courier_actions
WHERE  action = 'deliver_order'
   and date_part('month', time) = 9
   and date_part('year', time) = 2022
GROUP BY courier_id having count(action) = 1

14.Задание:

Из таблицы user_actions отберите пользователей, у которых последний заказ был создан до 8 сентября 2022 года.

Выведите только их id, дату создания заказа выводить не нужно.

Результат отсортируйте по возрастанию id пользователя.

Поле в результирующей таблице: user_id
select user_id 
from user_actions
where action = 'create_order'
group by user_id
having max(time) < '2022-09-08'
order by user_id

15/ Задание:

Разбейте заказы из таблицы orders на 3 группы в зависимости от количества товаров, попавших в заказ:

Малый (от 1 до 3 товаров);
Средний (от 4 до 6 товаров);
Большой (7 и более товаров).
Посчитайте число заказов, попавших в каждую группу. Группы назовите соответственно «Малый», «Средний», «Большой» (без кавычек).

Выведите наименования групп и число товаров в них. Колонку с наименованием групп назовите order_size, а колонку с числом заказов — orders_count.

Отсортируйте полученную таблицу по колонке с числом заказов по возрастанию.

Поля в результирующей таблице: order_size, orders_count

Пояснение:

Для определения числа товаров в заказе подойдёт функция array_length, которую мы рассматривали в прошлом уроке.

Заказ может содержать несколько единиц одного и того же товара, при определении размера заказа учитывайте все, как мы делали раньше.

Вспомнить, как работает условная конструкция CASE, можно на этом шаге.

SELECT case when array_length(product_ids, 1) >= 7 then 'Большой'
            when array_length(product_ids, 1) >= 4 then 'Средний'
            else 'Малый' end as order_size,
       count(order_id) as orders_count
FROM   orders
GROUP BY order_size
ORDER BY orders_count
16. Задание:

Разбейте пользователей из таблицы users на 4 возрастные группы:

от 18 до 24 лет;
от 25 до 29 лет;
от 30 до 35 лет;
не младше 36.
Посчитайте число пользователей, попавших в каждую возрастную группу. Группы назовите соответственно «18-24», «25-29», «30-35», «36+» (без кавычек).

В расчётах не учитывайте пользователей, у которых не указана дата рождения. Как и в прошлых задачах, в качестве возраста учитывайте число полных лет.

Выведите наименования групп и число пользователей в них. Колонку с наименованием групп назовите group_age, а колонку с числом пользователей — users_count.

Отсортируйте полученную таблицу по колонке с наименованием групп по возрастанию.

Поля в результирующей таблице: group_age, users_count

Пояснение:

Для решения этой задачи подойдёт конструкция CASE.

Ваши расчёты могут отличаться от ожидаемого результата, так как время не стоит на месте.

SELECT case when date_part('year', age(birth_date))::integer >= 36 then '36+'
            when date_part('year', age(birth_date))::integer >= 30 then '30-35'
            when date_part('year', age(birth_date))::integer >= 25 then '25-29'
            else '18-24' end as group_age,
       count(user_id) as users_count
FROM   users
WHERE  birth_date is not null
GROUP BY group_age
ORDER BY group_age

17.Задание:

По данным из таблицы orders рассчитайте средний размер заказа по выходным и будням.

Группу с выходными днями (суббота и воскресенье) назовите «weekend», а группу с будними днями (с понедельника по пятницу) — «weekdays» (без кавычек).

В результат включите две колонки: колонку с группами назовите week_part, а колонку со средним размером заказа — avg_order_size. 

Средний размер заказа округлите до двух знаков после запятой.

Результат отсортируйте по колонке со средним размером заказа — по возрастанию.

Поля в результирующей таблице: week_part, avg_order_size

Пояснение:

Для получения дня недели из даты подойдут функции DATE_PART и TO_CHAR.

Ваше решение:

SELECT case when date_part('dow', creation_time) between 1 and
                 5 then 'weekdays'
            else 'weekend' end as week_part,
       round(avg(array_length(product_ids, 1)), 2) as avg_order_size
FROM   orders
GROUP BY week_part
ORDER BY avg_order_size


Вариант верного решения:

SELECT case when to_char(creation_time, 'Dy') in ('Sat', 'Sun') then 'weekend'
            else 'weekdays' end as week_part,
       round(avg(array_length(product_ids, 1)), 2) as avg_order_size
FROM   orders
GROUP BY week_part
ORDER BY avg_order_size
18. Задание:

Для каждого пользователя в таблице user_actions посчитайте общее количество оформленных заказов и долю отменённых заказов.

Новые колонки назовите соответственно orders_count и cancel_rate. Колонку с долей отменённых заказов округлите до двух знаков после запятой.

В результат включите только тех пользователей, которые оформили больше трёх заказов и у которых показатель cancel_rate составляет не менее 0.5.

Результат отсортируйте по возрастанию id пользователя.

Поля в результирующей таблице: user_id, orders_count, cancel_rate

Пояснение:

Вспомнить, как работает ключевое слово FILTER, можно в этом уроке.

Мы сознательно исключаем из результата пользователей с небольшим числом заказов: например, пользователь мог оформить всего один заказ и затем отменить его — в итоге для него cancel_rate составит 100%, но это не совсем то, что нас интересует.

Помните, что для получения корректного результата деления нужно хотя бы одно из значений привести к типу DECIMAL.
SELECT user_id,
       round(count(distinct order_id) filter (WHERE action = 'cancel_order')::decimal / count(distinct order_id),
             2) as cancel_rate,
       count(distinct order_id) as orders_count
FROM   user_actions
GROUP BY user_id having round(count(distinct order_id) filter (
WHERE  action = 'cancel_order')::decimal / count(distinct order_id), 2) >= 0.5
   and count(distinct order_id) > 3
ORDER BY user_id

19. Для каждого дня недели в таблице user_actions посчитайте:

Общее количество оформленных заказов.
Общее количество отменённых заказов.
Общее количество неотменённых заказов (т.е. доставленных).
Долю неотменённых заказов в общем числе заказов (success rate).
Новые колонки назовите соответственно created_orders, canceled_orders, actual_orders и success_rate. Колонку с долей неотменённых заказов округлите до трёх знаков после запятой.

Все расчёты проводите за период с 24 августа по 6 сентября 2022 года включительно, чтобы во временной интервал попало равное количество разных дней недели.

Группы сформируйте следующим образом: выделите день недели из даты с помощью функции to_char с параметром 'Dy', также выделите порядковый номер дня недели с помощью функции DATE_PART с параметром 'isodow'. Далее сгруппируйте данные по двум полям и проведите все необходимые расчёты.

В результате должна получиться группировка по двум колонкам: с порядковым номером дней недели и их сокращёнными наименованиями.

Результат отсортируйте по возрастанию порядкового номера дня недели.

Поля в результирующей таблице: weekday_number, weekday, created_orders, canceled_orders, actual_orders, success_rate

Пояснение:

В целях упрощения расчётов в рамках этой задачи полагаем, что отмена заказа всегда происходит практически сразу после его создания, т.е. в тот же день. Случаями, когда заказ создаётся незадолго до полуночи, а отмена выпадает на следующий день, мы пренебрегаем.

Номер дня недели мы дополнительно выделяем для того, чтобы вывести наименования дней недели и одновременно отсортировать все записи в соответствии с их порядком.

Помните, что при расчёте относительных показателей для получения корректного результата деления нужно хотя бы одно из значений привести к типу DECIMAL.

SELECT date_part('isodow', time)::int as weekday_number,
       to_char(time, 'Dy') as weekday,
       count(order_id) filter (WHERE action = 'create_order') as created_orders,
       count(order_id) filter (WHERE action = 'cancel_order') as canceled_orders,
       count(order_id) filter (WHERE action = 'create_order') - count(order_id) filter (WHERE action = 'cancel_order') as actual_orders,
       round((count(order_id) filter (WHERE action = 'create_order') - count(order_id) filter (WHERE action = 'cancel_order'))::decimal / count(order_id) filter (WHERE action = 'create_order'),
             3) as success_rate
FROM   user_actions
WHERE  time >= '2022-08-24'
   and time < '2022-09-07'
GROUP BY weekday_number, weekday
ORDER BY weekday_number

ПОДЗАПРОСЫ
1. Используя данные из таблицы user_actions, рассчитайте среднее число заказов всех пользователей нашего сервиса.

Для этого сначала в подзапросе посчитайте, сколько заказов сделал каждый пользователь, а затем обратитесь к результату подзапроса в блоке FROM и уже в основном запросе усредните количество заказов по всем пользователям.

Полученное среднее число заказов всех пользователей округлите до двух знаков после запятой. Колонку с этим значением назовите orders_avg.

Поле в результирующей таблице: orders_avg
SELECT round(avg(orders_count), 2) as orders_avg
FROM   (SELECT user_id,
               count(order_id) as orders_count
        FROM   user_actions
        WHERE  action = 'create_order'
        GROUP BY user_id) as t1

2. Задание:

Повторите запрос из предыдущего задания, но теперь вместо подзапроса используйте оператор WITH и табличное выражение.

Условия задачи те же: используя данные из таблицы user_actions, рассчитайте среднее число заказов всех пользователей.

Полученное среднее число заказов округлите до двух знаков после запятой. Колонку с этим значением назовите orders_avg.

Поле в результирующей таблице: orders_avg

with t1 as (SELECT user_id,
                   count(order_id) as orders_count
            FROM   user_actions
            WHERE  action = 'create_order'
            GROUP BY user_id)
SELECT round(avg(orders_count), 2) as orders_avg
FROM   t1


3.Задание:

Выведите из таблицы products информацию о всех товарах кроме самого дешёвого.

Результат отсортируйте по убыванию id товара.

Поля в результирующей таблице: product_id, name, price

SELECT product_id,
       name,
       price
FROM   products
WHERE  price != (SELECT min(price)
                 FROM   products)
ORDER BY product_id desc

4.Задание:

Выведите информацию о товарах в таблице products, цена на которые превышает среднюю цену всех товаров на 20 рублей и более. Результат отсортируйте по убыванию id товара.

Поля в результирующей таблице: product_id, name, price

SELECT product_id,
       name,
       price
FROM   products
WHERE  price >= (SELECT avg(price)
                 FROM   products) + 20
ORDER BY product_id desc

5. Посчитайте количество уникальных клиентов в таблице user_actions, сделавших за последнюю неделю хотя бы один заказ.

Полученную колонку с числом клиентов назовите users_count. В качестве текущей даты, от которой откладывать неделю, используйте последнюю дату в той же таблице user_actions.

Поле в результирующей таблице: users_count
SELECT count(distinct user_id) as users_count
FROM   user_actions
WHERE  action = 'create_order'
   and time between (SELECT max(time)
                  FROM   user_actions) - interval '1 week' and (SELECT max(time)
                                              FROM   user_actions)
6.Задание:

С помощью функции AGE и агрегирующей функции снова определите возраст самого молодого курьера мужского пола в таблице couriers, но в этот раз при расчётах в качестве первой даты используйте последнюю дату из таблицы courier_actions.

Чтобы получить именно дату, перед применением функции AGE переведите последнюю дату из таблицы courier_actions в формат DATE, как мы делали в этом задании.

Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип VARCHAR. Полученную колонку со значением возраста назовите min_age.

Поле в результирующей таблице: min_age

Пояснение:

В этой задаче результат подзапроса выступает в качестве аргумента функции. Чтобы весь запрос выглядел компактнее, для приведения данных к другому типу можно использовать формат записи с двумя двоеточиями — ::.

Также обратите внимание, что для получения необходимого результата мы обращаемся к разным таблицам в рамках одного общего запроса.

SELECT min(age((SELECT max(time)::date
                FROM   courier_actions), birth_date))::varchar as min_age
FROM   couriers
WHERE  sex = 'male'
7.Задание:

Из таблицы user_actions с помощью подзапроса или табличного выражения отберите все заказы, которые не были отменены пользователями.

Выведите колонку с id этих заказов. Результат запроса отсортируйте по возрастанию id заказа.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поле в результирующей таблице: order_id

SELECT order_id 
FROM user_actions 
WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order') 
ORDER BY order_id LIMIT 1000;

Решение 2: 
with t1 as (SELECT order_id
            FROM   user_actions
            WHERE  action = 'cancel_order')
SELECT order_id
FROM   user_actions
WHERE  order_id not in (SELECT*
                        FROM   t1)
ORDER BY order_id limit 1000;



8.Задание:

Используя данные из таблицы user_actions, рассчитайте, сколько заказов сделал каждый пользователь и отразите это в столбце orders_count.

В отдельном столбце orders_avg напротив каждого пользователя укажите среднее число заказов всех пользователей, округлив его до двух знаков после запятой.

Также для каждого пользователя посчитайте отклонение числа заказов от среднего значения. Отклонение считайте так: число заказов «минус» округлённое среднее значение. Колонку с отклонением назовите orders_diff.

Результат отсортируйте по возрастанию id пользователя. Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: user_id, orders_count, orders_avg, orders_diff


Решение 1
with t1 as (SELECT user_id,
                   count(order_id) as orders_count
            FROM   user_actions
            WHERE  action = 'create_order'
            GROUP BY user_id)
SELECT user_id,
       count(order_id) filter (WHERE action = 'create_order') as orders_count,
       (SELECT round(avg(orders_count), 2) as orders_avg
 FROM   t1), count(order_id) filter (
WHERE  action = 'create_order') - (SELECT round(avg(orders_count), 2) as orders_avg
                                   FROM   t1) as orders_diff
FROM   user_actions
GROUP BY user_id
ORDER BY user_id limit 1000

Решение 2 

with t1 as (SELECT user_id,
                   count(order_id) as orders_count
            FROM   user_actions
            WHERE  action = 'create_order'
            GROUP BY user_id)
SELECT user_id,
       orders_count,
       round((SELECT avg(orders_count)
       FROM   t1), 2) as orders_avg, orders_count - round((SELECT avg(orders_count)
                                                    FROM   t1), 2) as orders_diff
FROM   t1
ORDER BY user_id limit 1000

Пояснение:

В этой задаче можно использовать подзапрос, написанный в первых заданиях этого урока. Чтобы не пришлось дважды писать один и тот же подзапрос, можно использовать оператор WITH.


9. Задание:

Назначьте скидку 15% на товары, цена которых превышает среднюю цену на все товары на 50 и более рублей, а также скидку 10% на товары, цена которых ниже средней на 50 и более рублей. Цену остальных товаров внутри диапазона (среднее - 50; среднее + 50) оставьте без изменений. При расчёте средней цены, округлите её до двух знаков после запятой.

Выведите информацию о всех товарах с указанием старой и новой цены. Колонку с новой ценой назовите new_price.

Результат отсортируйте сначала по убыванию прежней цены в колонке price, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, new_price
Решение 1. 
with t1 as (SELECT price
            FROM   products
            WHERE  price >= (SELECT round(avg(price), 2)
                             FROM   products) + 50), t2 as (SELECT price
                               FROM   products
                               WHERE  price <= (SELECT round(avg(price), 2)
                                                FROM   products) - 50)
SELECT product_id,
       name,
       price,
       case when price in (SELECT price
                    FROM   t1) then price - price*0.15 when price in (SELECT price
                                                  FROM   t2) then price - price*0.10 else price end as new_price
FROM   products
ORDER BY price desc, product_id

Решение 2. 

with avg_price as (SELECT round(avg(price), 2) as price
                   FROM   products)
SELECT product_id,
       name,
       price,
       case 
       when price >= (SELECT * FROM   avg_price) + 50 then price*0.85 
       when price <= (SELECT * FROM   avg_price) - 50 then price*0.9 
       else price 
       end as new_price
FROM   products
ORDER BY price desc, product_id

10. Выясните, есть ли в таблице courier_actions такие заказы, которые были приняты курьерами, но не были созданы пользователями. Посчитайте количество таких заказов.

Колонку с числом заказов назовите orders_count.

Поле в результирующей таблице: orders_count

SELECT count(distinct order_id) as orders_count
FROM   courier_actions
WHERE  action = 'accept_order'
   and order_id not in (SELECT order_id
                     FROM   user_actions)
